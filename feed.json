{
    "version": "https://jsonfeed.org/version/1",
    "title": "花圃",
    "subtitle": "理想的种子，于现实中绽放",
    "icon": "https://zimu-66ccff.github.io/images/favicon.ico",
    "description": "干净澄澈，真诚自然",
    "home_page_url": "https://zimu-66ccff.github.io",
    "items": [
        {
            "id": "https://zimu-66ccff.github.io/globLearn/",
            "url": "https://zimu-66ccff.github.io/globLearn/",
            "title": "glob语法详解",
            "date_published": "2023-11-16T10:55:54.000Z",
            "content_html": "<h1 id=\"基础语法\"><a class=\"anchor\" href=\"#基础语法\">#</a> 基础语法</h1>\n<h2 id=\"分隔符和片段\"><a class=\"anchor\" href=\"#分隔符和片段\">#</a> 分隔符和片段</h2>\n<h3 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念：</h3>\n<p>分隔符是・，通过・得到的数组每一项是片段。</p>\n<h3 id=\"示例\"><a class=\"anchor\" href=\"#示例\">#</a> 示例：</h3>\n<ul>\n<li><code>src/index.js</code>  有两个片段，分别是  <code>src</code>  和  <code>index.js</code></li>\n<li><code>src/**/*.js</code>  有三个片段，分别是 <code> src</code> 、 <code>**</code>  和  <code>*.js</code></li>\n</ul>\n<h2 id=\"单个星号\"><a class=\"anchor\" href=\"#单个星号\">#</a> 单个星号</h2>\n<h3 id=\"概念-2\"><a class=\"anchor\" href=\"#概念-2\">#</a> 概念：</h3>\n<p>单个星号  <code>*</code>  用于匹配单个片段中的零个或多个字符。</p>\n<h3 id=\"示例-2\"><a class=\"anchor\" href=\"#示例-2\">#</a> 示例：</h3>\n<ul>\n<li><code>src/*.js</code>  表示 <code>src</code>  目录下所有以  <code>js</code>  结尾的文件，但是不能匹配  <code>src </code> 子目录中的文件，例如  <code>src/login/login.js</code></li>\n<li><code>/home/*/.bashrc </code> 匹配所有用户的 .bashrc 文件<div class=\"note danger\">\n<p>需要注意的是， <code>*</code>  不能匹配分隔符  <code>/</code> ，也就是说不能跨片段匹配字符。</p>\n</div>\n</li>\n</ul>\n<h2 id=\"问号\"><a class=\"anchor\" href=\"#问号\">#</a> 问号</h2>\n<h3 id=\"概念-3\"><a class=\"anchor\" href=\"#概念-3\">#</a> 概念：</h3>\n<p>问号  <code>?</code>  匹配单个片段中的单个字符。</p>\n<h3 id=\"示例-3\"><a class=\"anchor\" href=\"#示例-3\">#</a> 示例：</h3>\n<ul>\n<li><code>test/?at.js </code> 匹配形如  <code>test/cat.js</code> 、 <code>test/bat.js</code>  等所有 3 个字符且后两位是  <code>at</code>  的 js 文件，但是不能匹配  <code>test/flat.js</code></li>\n<li><code>src/index.??</code>  匹配  <code>src</code>  目录下以  <code>index</code>  打头，后缀名是两个字符的文件，例如可以匹配  <code>src/index.js </code> 和  <code>src/index.md</code> ，但不能匹配  <code>src/index.jsx</code></li>\n</ul>\n<h2 id=\"中括号\"><a class=\"anchor\" href=\"#中括号\">#</a> 中括号</h2>\n<h3 id=\"概念-4\"><a class=\"anchor\" href=\"#概念-4\">#</a> 概念：</h3>\n<p>同样是匹配单个片段中的单个字符，但是字符集只能从括号内选择，如果字符集内有  <code>-</code> ，表示范围。</p>\n<h3 id=\"示例-4\"><a class=\"anchor\" href=\"#示例-4\">#</a> 示例：</h3>\n<ul>\n<li><code>test/[bc]at.js </code> 只能匹配  <code>test/bat.js</code>  和  <code>test/cat.js</code></li>\n<li><code>test/[c-f]at.js</code>  能匹配 <code> test/cat.js</code> 、 <code>test/dat.js</code> 、 <code>test/eat.js</code>  和  <code>test/fat.js</code></li>\n</ul>\n<h2 id=\"惊叹号\"><a class=\"anchor\" href=\"#惊叹号\">#</a> 惊叹号</h2>\n<h3 id=\"概念-5\"><a class=\"anchor\" href=\"#概念-5\">#</a> 概念：</h3>\n<p>表示取反，即排除那些去掉惊叹号之后能够匹配到的文件。</p>\n<h3 id=\"示例-5\"><a class=\"anchor\" href=\"#示例-5\">#</a> 示例：</h3>\n<p><code>test/[!bc]at.js</code>  不能匹配  <code>test/bat.js</code>  和  <code>test/cat.js</code> ，但是可以匹配  <code>test/fat.js</code> <br />\n <code>!test/tmp/**</code>  排除  <code>test/tmp</code>  目录下的所有目录和文件</p>\n<h1 id=\"扩展语法\"><a class=\"anchor\" href=\"#扩展语法\">#</a> 扩展语法</h1>\n<h2 id=\"两个星号\"><a class=\"anchor\" href=\"#两个星号\">#</a> 两个星号</h2>\n<h3 id=\"概念-6\"><a class=\"anchor\" href=\"#概念-6\">#</a> 概念：</h3>\n<p>两个星号  <code>**</code>  可以跨片段匹配零个或多个字符，也就是说  <code>**</code>  是递归匹配所有文件和目录的，如果后面有分隔符，即  <code>**/ </code> 的话，则表示只递归匹配所有目录（不含隐藏目录）。</p>\n<h3 id=\"示例-6\"><a class=\"anchor\" href=\"#示例-6\">#</a> 示例：</h3>\n<ul>\n<li><code>/var/log/**</code>  匹配  <code>/var/log</code>  目录下所有文件和文件夹，以及文件夹里面所有子文件和子文件夹</li>\n<li><code>/var/log/**/*.log</code>  匹配  <code>/var/log</code>  及其子目录下的所有以 .log 结尾的文件</li>\n<li><code>/home/*/.ssh/**/*.key</code>  匹配所有用户的  <code>.ssh</code>  目录及其子目录内的以  <code>.key</code>  结尾的文件</li>\n</ul>\n<h2 id=\"大括号\"><a class=\"anchor\" href=\"#大括号\">#</a> 大括号</h2>\n<h3 id=\"概念-7\"><a class=\"anchor\" href=\"#概念-7\">#</a> 概念：</h3>\n<p>匹配大括号内的所有模式，模式之间用逗号进行分隔，支持大括号嵌套，支持用  <code>..</code>  匹配连续的字符，即  <code>&#123;start..end&#125;</code>  语法。</p>\n<h3 id=\"示例-7\"><a class=\"anchor\" href=\"#示例-7\">#</a> 示例：</h3>\n<ul>\n<li><code>a.&#123;png,jp&#123;,e&#125;g&#125;</code>  匹配  <code>a.png</code> 、 <code>a.jpg</code> 、 <code>a.jpeg</code></li>\n<li><code>&#123;a..c&#125;&#123;1..2&#125;</code>  匹配  <code>a1`` a2</code>   <code>b1</code>   <code>b2 ``c1</code>   <code>c2</code></li>\n</ul>\n<div class=\"note info\">\n<p>注意： <code>&#123;&#125;</code>  与  <code>[]</code>  有一个很重要的区别：如果匹配的文件不存在， <code>[]</code>  会失去模式的功能，变成一个单纯的字符串，而 <code> &#123;&#125;</code>  依然可以展开。</p>\n</div>\n<h2 id=\"小括号\"><a class=\"anchor\" href=\"#小括号\">#</a> 小括号</h2>\n<h3 id=\"概念-8\"><a class=\"anchor\" href=\"#概念-8\">#</a> 概念：</h3>\n<p>小括号必须跟在 <code> ?</code> 、 <code>*</code> 、 <code>+</code> 、 <code>@</code> 、 <code>!</code>  后面使用，且小括号里面的内容是一组以  <code>| </code> 分隔符的模式集合，例如： <code>abc|a?c|ac*</code> 。</p>\n<h3 id=\"示例-8\"><a class=\"anchor\" href=\"#示例-8\">#</a> 示例：</h3>\n<ul>\n<li><code>?(pattern|pattern|pattern)</code> ：匹配 0 次或 1 次给定的模式</li>\n<li><code>*(pattern|pattern|pattern)</code> ：匹配 0 次或多次给定的模式</li>\n<li><code>+(pattern|pattern|pattern)</code> ：匹配 1 次或多次给定的模式</li>\n<li><code>@(pattern|pattern|pattern)</code> ：严格匹配给定的模式</li>\n<li><code>!(pattern|pattern|pattern)</code> ：匹配非给定的模式</li>\n</ul>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "glob"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/gitLearn/",
            "url": "https://zimu-66ccff.github.io/gitLearn/",
            "title": "git命令详解",
            "date_published": "2023-11-16T09:39:47.000Z",
            "content_html": "<h1 id=\"创建本地-git-仓库\"><a class=\"anchor\" href=\"#创建本地-git-仓库\">#</a> 创建本地 git 仓库</h1>\n<p><code>git init</code>  会在当前目录下创建一个.git 隐藏文件夹</p>\n<h1 id=\"将本地仓库和远程仓库相关联\"><a class=\"anchor\" href=\"#将本地仓库和远程仓库相关联\">#</a> 将本地仓库和远程仓库相关联</h1>\n<ol>\n<li><code>git remote add origin &lt;registry-url&gt;</code>  将本地仓库和远程仓库相关联</li>\n<li><code>git remote -v</code>  查看关联的远程仓库</li>\n</ol>\n<h1 id=\"将本地对应的代码提交到暂存区\"><a class=\"anchor\" href=\"#将本地对应的代码提交到暂存区\">#</a> 将本地对应的代码提交到暂存区：</h1>\n<ol>\n<li><code>git add &lt;file&gt; </code> 将指定的 file 提交到暂存区</li>\n<li><code>git add . </code> 将所有有变动的文件提交到暂存区</li>\n</ol>\n<h1 id=\"将暂存区的代码提交到本地-git-仓库\"><a class=\"anchor\" href=\"#将暂存区的代码提交到本地-git-仓库\">#</a> 将暂存区的代码提交到本地 git 仓库：</h1>\n<p><code>git commit -m '&lt;commit-msg&gt;'</code></p>\n<h1 id=\"查看文件状态\"><a class=\"anchor\" href=\"#查看文件状态\">#</a> 查看文件状态</h1>\n<p><code>git status</code>  可以查看哪些文件被修改了，哪些文件提交到暂存区了但是还没有 commit</p>\n<h1 id=\"提交本地-git-仓库代码到远程仓库\"><a class=\"anchor\" href=\"#提交本地-git-仓库代码到远程仓库\">#</a> 提交本地 git 仓库代码到远程仓库:</h1>\n<ol>\n<li><code>git push</code>  会将当前分支的最新的 commit 提交到远程仓库对应的分支，然后本地的对应的远程分支 ( <code>remotes/origin/对应当前分支名</code> ) 也会自动更新</li>\n<li><code>git push origin &lt;source&gt; </code> 会将本地的 <code>&lt;source&gt;分支</code> 的最新 commit 提交到远程仓库对应的分支，然后本地的对应的远程分支（ <code>remotes/origin/&lt;source&gt;</code> ）也会自动更新</li>\n<li><code>git push origin &lt;source&gt;:&lt;destination&gt;</code>  会将本地的 <code>&lt;source&gt;分支</code> 的最新 commit 提交到远程仓库的 <code>&lt;destination&gt;分支</code>  然后本地对应的远程分支 ( <code>remotes/origin&lt;destination&gt;</code> ) 也会自动更新。 如果 <code>&lt;destination&gt;分支</code> 不存在，会在远程仓库自动创建 <code>&lt;destination&gt;分支</code> ，然后在本地创建对应的远程分支 ( <code>remotes/origin/&lt;destination&gt;</code> ) 并更新</li>\n<li><code>git push origin :&lt;destination&gt; </code> 会在远程仓库直接删除 <code>&lt;destination&gt;</code>  (个人感觉这样设计是因为 push 了一个空给 <code>&lt;destination&gt;</code> ，所以 git 就理解为你要删除 <code>&lt;destination&gt;</code> )</li>\n</ol>\n<h1 id=\"拉取远程仓库代码\"><a class=\"anchor\" href=\"#拉取远程仓库代码\">#</a> 拉取远程仓库代码：</h1>\n<ol>\n<li><code>git fetch</code>  会拉取远程仓库的<ins>所有分支</ins>各自对应的最新代码 将远程仓库所有的分支各自的最新的 commit 添加到对应的本地的各个远程分支（ <code>remotes/origin/\\*</code> ） <ins>但是不会合并分支</ins>。<ins>也就是说 只需一次命令 就可以将远程仓库的所有的最新更新给拉下来</ins></li>\n<li><code>git fetch origin &lt;source&gt;</code>  拉取远程仓库的 <code>&lt;source&gt;分支</code> 的最新 commit 然后添加到本地对应的远程分支（ <code>remotes/origin/source</code> ）但是不会合并分支</li>\n<li><code>git fetch origin &lt;source&gt;:&lt;destination&gt; </code> 拉取远程仓库的 <code>&lt;source&gt;分支</code> 的最新 commit 然后添加到本地的 <code>&lt;destination&gt;分支</code>  但是不会合并分支。如果 <code>&lt;destination&gt;</code>  不存在，会在本地以当前分支为基本自动创建 <code>&lt;destination&gt;</code> 。<br />\n <code>git fetch origin :&lt;destination&gt;</code>  会在本地新建一个 <code>&lt;destination&gt;分支</code>  （感觉这样设计是因为，相当于 fetch 了一个空到本地，所以 git 就会理解为你要新建一个分支）</li>\n</ol>\n<h1 id=\"拉取远程仓库代码并和本地的分支做一个合并\"><a class=\"anchor\" href=\"#拉取远程仓库代码并和本地的分支做一个合并\">#</a> 拉取远程仓库代码，并和本地的分支做一个合并：</h1>\n<ol>\n<li><code>git pull</code>  其实就是  <code>git fetch</code>  和  <code>git merge</code>  的缩写，在  <code>git fetch</code>  的基础上 会将远程分支（ <code>remotes/origin/对应当前分支名</code> ）和本地当前分支做一个合并</li>\n<li><code>git pull origin &lt;source&gt;</code>  会拉取远程仓库的 <code>&lt;source&gt;分支</code> 的最新 commit, 然后添加到对应的本地的远程分支上面 ( <code>remotes/origin/&lt;source&gt;</code> )，再将这个远程分支和本地当前分支做一个合并</li>\n<li><code>git pull origin &lt;source&gt;:&lt;destination&gt;</code>  会将远程仓库的 <code>&lt;source&gt;分支</code> 的最新的 commit 添加到本地的 <code>&lt;destination&gt;</code>  分支上面（如果 <code>&lt;destination&gt;</code>  不存在，会自动创建），然后将 <code>&lt;destination&gt;</code>  合并到当前分支。</li>\n</ol>\n<h1 id=\"创建分支\"><a class=\"anchor\" href=\"#创建分支\">#</a> 创建分支：</h1>\n<p><code>git branch &lt;branch-name&gt;</code></p>\n<h1 id=\"查看分支\"><a class=\"anchor\" href=\"#查看分支\">#</a> 查看分支：</h1>\n<ol>\n<li><code>git branch</code>  查看本地分支</li>\n<li><code>git branch -r</code>  查看远程分支</li>\n<li><code>git branch -a</code>  查看所有分支</li>\n</ol>\n<h1 id=\"删除分支\"><a class=\"anchor\" href=\"#删除分支\">#</a> 删除分支：</h1>\n<ol>\n<li><code>git branch -d &lt;branch-name&gt;</code>  当被删除分支有新内容没有被合并的时候，使用 - d，会提示该分支有新内容没有被合并，不执行删除。</li>\n<li><code>git branch -D &lt;branch-name&gt;</code>  当被删除分支有新内容没有被合并的时候，使用 - D，会直接删除</li>\n</ol>\n<h1 id=\"切换分支\"><a class=\"anchor\" href=\"#切换分支\">#</a> 切换分支:</h1>\n<p><code>git checkout &lt;branch-name&gt;</code></p>\n<h1 id=\"创建并切换分支\"><a class=\"anchor\" href=\"#创建并切换分支\">#</a> 创建并切换分支:</h1>\n<p><code>git checkout -b &lt;branch-name&gt;</code></p>\n<h1 id=\"将分支移动到指定-commit\"><a class=\"anchor\" href=\"#将分支移动到指定-commit\">#</a> 将分支移动到指定 commit：</h1>\n<p><code>git branch -f &lt;branch-name&gt; &lt;commit-hash&gt;</code> <br />\n 以<ins>相对移动</ins>的方式将分支移动到指定 commit<br />\n <code>git branch -f &lt;branch-name&gt; HEAD&#123;^[num], ~[num]&#125;</code></p>\n<h1 id=\"代码回滚\"><a class=\"anchor\" href=\"#代码回滚\">#</a> 代码回滚</h1>\n<ol>\n<li><code>git reset --mixed &lt;commit-hash&gt;</code>   <code>git reset &lt;commit-hash&gt;</code>  默认就是这个命令，将<ins>暂存区， 本地 git 仓库</ins>回滚到指定 commit</li>\n<li><code>git reset --hard &lt;commit-hash&gt;</code>  将<ins>本地代码，暂存区，本地 git 仓库</ins>回滚到指定 commit</li>\n<li><code>git reset --soft &lt;commit-hash&gt;</code>  将<ins>本地 git 仓库</ins>回滚到指定 commit</li>\n<li><code>git revert &lt;commit-hash&gt; </code> 会在当前分支新添加一个 commit 这个 commit 的作用是抵消之前的对应的 commit，也可以用于回滚分支。<br />\n<img data-src=\"https://i.imgs.ovh/2023/11/16/ndPCv.png\" alt=\"ndPCv.png\" /><div class=\"note info\">\n<p>从<ins>数据安全</ins>上角度， <code>revert</code>  比  <code>reset</code>  安全，因为它的操作可以回溯，反转了还可以倒回来。 <code>reset </code> 比较彻底，是直接丢弃了，不过可以考虑想第一个例子中创建一个备份分支来保证安全。<br />\n从<ins>分支历史</ins>的长期维护角度， <code>reset</code>  的历史比较干净， <code>revert </code> 的反转提交没多大意义，毕竟很少有需求让你滚来滚去的。<br />\n在被撤销提交，不在分支顶端的场景上， <code>reset</code>  无法使用， <code>revert</code>  可以做到，。</p>\n</div>\n</li>\n</ol>\n<h1 id=\"合并分支\"><a class=\"anchor\" href=\"#合并分支\">#</a> 合并分支：</h1>\n<ol>\n<li><code>git merge &lt;branch-name&gt;</code>  将分支合并到当前分支，会在当前分支新增一个 commit（用来合并需要合并的分支）并且当前分支会自动更新 <ins>不是线性的</ins></li>\n<li><code>git rebase &lt;target-branch-name&gt;</code>  将当前分支有的，但是目标分支没有的 commit 直接线性的添加到目标分支 但是目标分支不会自动更新 <ins>是线性的</ins><br />\n<img data-src=\"https://i.imgs.ovh/2023/11/16/nYGdI.png\" alt=\"gitlearn01.png\" /></li>\n</ol>\n<h1 id=\"合并指定的-commit\"><a class=\"anchor\" href=\"#合并指定的-commit\">#</a> 合并指定的 commit：</h1>\n<ol>\n<li><code>git check-chery &lt;commit-hash&gt;</code>  将指定的 commit 添加到当前分支 可以一次添加多个  <code>commit</code></li>\n</ol>\n<h1 id=\"切换-head\"><a class=\"anchor\" href=\"#切换-head\">#</a> 切换 HEAD:</h1>\n<ol>\n<li><code>git checkout &lt;commit hash&gt;</code></li>\n<li><code>git checkout HEAD&#123;^[num], ~[num]&#125; </code> 注：^ 后面的 num 指的是切换到第几个 parent commit (横向的) ~ 后面的 num 是指以当前 HEAD 为参考，切换到上面第几个 commit</li>\n</ol>\n<h1 id=\"查看-head-指针的移动记录\"><a class=\"anchor\" href=\"#查看-head-指针的移动记录\">#</a> 查看 HEAD 指针的移动记录</h1>\n<p><code>git reflog</code></p>\n<h1 id=\"查看分支历史\"><a class=\"anchor\" href=\"#查看分支历史\">#</a> 查看分支历史</h1>\n<ol>\n<li><code>git log</code>  显示 commit 的 SHA1 值，创建作者和时间，提交信息，会多行显示</li>\n<li><code>git log --oneline</code>  只显示提交的 SHA1 值和提交信息，SHA1 还是缩短显示前几位，只在一行显示</li>\n</ol>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "git"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/npmLink/",
            "url": "https://zimu-66ccff.github.io/npmLink/",
            "title": "npm link 详解",
            "date_published": "2023-11-12T13:20:41.000Z",
            "content_html": "<h1 id=\"npm-link-的应用场景\"><a class=\"anchor\" href=\"#npm-link-的应用场景\">#</a> npm link 的应用场景</h1>\n<ol>\n<li>开发脚手架时，在本地调试命令<br />\n开发脚手架时，在项目所在目录，执行 <code>npm link</code>  命令，就可以在全局执行项目的 <code>package.json</code>  文件的 <code>bin</code>  属性里面配置的命令</li>\n<li>可以在项目里，直接使用本地包，从而对本地包进行调试<br />\n当我们开发包 <code>a</code>  时，可以在发布前直接 <code>npm link</code> ，将包 <code>a</code>  链接到全局，然后在项目里 <code>npm link a</code> ，这样就可以在项目里面使用包 <code>a</code> ，从而对包进行调试</li>\n<li>MultiRepo 多仓库多模块应用 本地开发时，多模块之间共享代码的一种解决方案<br />\n当仓库 <code>a</code>  要使用仓库 <code>b</code>  提供的代码的时候，可以在 <code>b</code>  仓库目录下， <code>npm link</code>  从而将仓库 <code>b</code>  链接到全局，然后再在仓库 <code>a</code>  里执行 <code>npm link b</code> ， 然后就可以在 <code>a</code>  里导入 <code>b</code>  了。从而实现多仓库共享代码</li>\n</ol>\n<h1 id=\"本地包里执行-npm-link-发生了什么\"><a class=\"anchor\" href=\"#本地包里执行-npm-link-发生了什么\">#</a> 本地包里执行 npm link 发生了什么？</h1>\n<ol>\n<li>\n<p>在 npm 的全局模块目录（node 安装目录下的 <code>node_modules</code> ）下会创建一个 <code>软连接（符号链接）</code> ，指向本地包。</p>\n</li>\n<li>\n<p>根据 <code>bin</code>  配置的命令，在可执行目录下创建一个符号链接，指向 <code>bin</code>  里配置的可执行文件。<br />\n例如，如果你的 <code> package.json</code>  文件中有如下配置：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your-project\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token property\">\"bin\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token property\">\"your-script\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./bin/your-script.js\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>执行  <code>npm link</code>  后，将在全局的可执行文件目录下创建一个名为  <code>your-script</code>  的符号链接，指向你项目中  <code>./bin/your-script.js</code>  文件。所以当我们在命令行里执行 <code>your-script</code>  的时候，实际相当于执行了 <code>./bin/your-script.js</code></p>\n<div class=\"note info\">\n<p>当我们全局安装包的时候，对 <code>bin</code>  的处理也是类似的，在全局的可执行目录下创建一个符号链接，指向 npm 全局模块目录下我们安装的全局包对应的可执行文件</p>\n</div>\n</li>\n</ol>\n<h1 id=\"项目里面执行-npm-link-package-name-发生了什么\"><a class=\"anchor\" href=\"#项目里面执行-npm-link-package-name-发生了什么\">#</a> 项目里面执行  <code>npm link &lt;package-name&gt;</code>  发生了什么</h1>\n<ol>\n<li>在项目的 <code>node_modules</code>  目录下创建一个符号链接，指向 npm 的 <code>全局模块目录</code> 下对应的符号链接（这个符号链接是我们在对应的本地包里执行  <code>npm link</code>  的时候创建的）。然后当我们导入这个包的时候，就会在项目的 <code>node_modules</code>  里找，从而就会找到对应的符号链接，然后这个符号链接又指向 npm 全局模块目录下的符号链接，而这个符号链接又指向本地包文件，从而正确的导入和使用。</li>\n<li>在项目的 <code>node_modules/.bin</code>  目录下根据对应本地包的 <code>bin</code>  创建对应的符号链接指向 npm 全局模块的对应的符号链接的可执行文件。<div class=\"note info\">\n<p>当我们使用 <code>npx</code>  执行命令的时候，实际上是在 <code>node_modules/.bin</code>  找的对应的可执行文件执行的</p>\n</div>\n</li>\n</ol>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "npm link"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/whyMonorepo/",
            "url": "https://zimu-66ccff.github.io/whyMonorepo/",
            "title": "为什么选择monorepo架构",
            "date_published": "2023-11-10T00:14:05.000Z",
            "content_html": "<h1 id=\"monolith-和-multirepo-存在什么问题\"><a class=\"anchor\" href=\"#monolith-和-multirepo-存在什么问题\">#</a> Monolith 和 MultiRepo 存在什么问题</h1>\n<h2 id=\"monolith-单仓库巨石应用\"><a class=\"anchor\" href=\"#monolith-单仓库巨石应用\">#</a> Monolith 单仓库巨石应用</h2>\n<p>用一个 git 仓库来维护项目代码，随着业务复杂度的上升，代码量会急剧上升，最终项目会变得十分庞大，复杂， 难以继续维护，更新迭代，并且构建效率也会降低。</p>\n<ul>\n<li>存在的问题：\n<ol>\n<li>代码耦合度非常高，可能改了这里，又会影响那里，并且当我们排查问题时，难度也变得非常高，可能很多时间都花在了找代码上面。</li>\n<li>代码量非常大，项目构建的效率低下，明明只改了一点点代码，却要重新构建整个代码，构建花费的时间非常长。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"multirepo-多仓库多模块应用\"><a class=\"anchor\" href=\"#multirepo-多仓库多模块应用\">#</a> MultiRepo 多仓库多模块应用</h2>\n<p>将一个项目拆解为多个多个模块，放在多个 git 仓库里面管理，直接的对项目进行了解耦，每个单独的模块都可以独立的编码，测试，发布。</p>\n<ul>\n<li>存在的问题\n<ol>\n<li>各个仓库之间的代码共享非常困难，粗糙，一般想要进行代码的共享只有如下几种方式：\n<ol>\n<li>将需要共享的代码复制粘贴到自己的仓库里<br />\n这种方式会明显的造成<ins>代码体积变大</ins>，从而<ins>影响构建效率</ins></li>\n<li>将需要共享的代码单独维护成一个仓库，发布成 npm 包，<br />\n这样方式很麻烦，<ins>每次都需要，重新发布 npm 包，然后在使用了这些共享的代码的仓库里 <code>npm install</code>  更新 npm 包</ins>。<br />\n<ins>并且当维护的 npm 包出现了 <code>break change</code>  的时候，只有等到 npm 包发布，并且各个仓库更新了 npm 包的时候，才能发现问题，问题发现不及时，导致排查问题，解决问题，十分困难</ins>。</li>\n<li>通过 <code>npm link</code>  来实现本地开发的时候共享代码，这种方式相比上面两种方式好了很多，但是依旧需要手动在需要共享代码的仓库里 <code>npm link</code> ，在需要使用其他仓库共享的代码的仓库里 <code>npm link &lt;package-name&gt;</code></li>\n</ol>\n</li>\n<li>版本管理很困难，当一个仓库有更新，需要发布的时候，需要在其他所有依赖这个仓库的仓库里执行 <code>npm install</code>  来使用这个刚更新仓库的最新版本。</li>\n<li>无法积累一个统一的工程化配置，从而复用，每次有新的项目的时候都要重新配置一次几乎一摸一样的， <code>ci</code> , <code>lint</code> ,  <code>构建</code> ，等流程</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"采用-monorepo-架构-可以解决这些问题吗会有哪些好处\"><a class=\"anchor\" href=\"#采用-monorepo-架构-可以解决这些问题吗会有哪些好处\">#</a> 采用 Monorepo 架构 可以解决这些问题吗？会有哪些好处</h1>\n<h2 id=\"将-monolith-巨石应用-换成-monorepo-架构\"><a class=\"anchor\" href=\"#将-monolith-巨石应用-换成-monorepo-架构\">#</a> 将 Monolith 巨石应用 换成 Monorepo 架构</h2>\n<ol>\n<li>将巨石应用，分为了不同的模块，在一定程度上进行了<ins>解耦</ins>，明显的降低了耦合性，既<ins>降低了维护成本（找代码，改代码）</ins>，<ins>也降低了新人上手门槛</ins>。</li>\n<li>当代码有更新，有变动的时候，只需要进行<ins>增量构建</ins>，只构建，发布，有变动的模块和使用了有变动的模块的模块，而不需要构建所有的代码，大大提升了<ins>构建效率</ins>。</li>\n</ol>\n<h2 id=\"将-multirepo-多仓库多模块应用-换成-monorepo-架构\"><a class=\"anchor\" href=\"#将-multirepo-多仓库多模块应用-换成-monorepo-架构\">#</a> 将 MultiRepo 多仓库多模块应用 换成 Monorepo 架构</h2>\n<ol>\n<li>模块之间的代码共享，更加<ins>便捷</ins>，<ins>安全</ins>，<ins>问题发现更加及时</ins>。所有的模块都在一个仓库里，可以很轻松的使用维护的对外共享代码的模块共享的代码，并且当对外共享代码的模块出现问题时，在<ins>开发阶段</ins>就可以及时发现，解决，而不是像 <code>MultiRepo</code>  一样，只能等到 npm 包发布，才能发现。</li>\n<li>现代的众多 <code>monorepo</code>  工具可以实现<ins>自动的版本管理</ins>，当有模块更新的时候，自动更新该模块，和使用了该模块的模块。</li>\n<li>可以<ins>积累下统一的工程化配置</ins>，多模块共同使用，<ins>当有新的项目的时候，可以作为一个新的模块直接接入，不再需要进行重复的工程化配置</ins>。</li>\n<li>所有的项目，公共函数库，公共组件库，都作为一个模块在一个仓库里，作为<ins>数据资产落地</ins>下来，<ins>便于新人快速上手</ins>，知晓有哪些公共函数，公共组件，可以使用，并维护，提升开发效率。</li>\n</ol>\n<h1 id=\"直接无脑的使用-monorepo-架构会带来哪些问题呢可以解决吗\"><a class=\"anchor\" href=\"#直接无脑的使用-monorepo-架构会带来哪些问题呢可以解决吗\">#</a> 直接无脑的使用 Monorepo 架构，会带来哪些问题呢，可以解决吗？</h1>\n<h2 id=\"可能带来的问题\"><a class=\"anchor\" href=\"#可能带来的问题\">#</a> 可能带来的问题</h2>\n<ol>\n<li>所有的项目都作为模块在同一个仓库里，可能出现改了其他模块的代码，并且负责该模块的同事还不知道，结果出现了问题。</li>\n<li>在维护对外共享代码的模块（比如，组件库，函数库， hooks 库）的时候，无意间造成了 <code>break change</code> ，从而影响了其他使用了该模块的模块的正常运转。</li>\n<li>在更新对外共享代码的模块的时候，不通知更新内容，从而使其他同事不知道公共模块多了哪些东西，导致对外共享模块形同虚设，无法发挥作用。</li>\n</ol>\n<h2 id=\"解决方案\"><a class=\"anchor\" href=\"#解决方案\">#</a> 解决方案</h2>\n<p>团队需要有严格的 <code>commit msg</code>  规范，每次的 <code>commit msg</code>  必须附上，更改的模块名；当公共模块有更新的时候，必须写上更新内容，并告知团队成员，一方面当不小心造成 <code>break change</code>  时，团队成员能够及时发现，并解决。另一方面，团队成员可以及时知道公共模块更新了哪些内容，自己是否可以用到，从而放公共模块发挥作用。<br />\n团队需要有严格的 <code>code review</code>  作为兜底</p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>Monorepo 架构确实拥有着很大的优势（解耦；增量构建，提升构建效率；代码共享；积累统一的工程化配置，公共库，从而提高开发效率，积累数据资产；降低新人上手门槛），可以带来很多积极的作用，但是对团队规范有一定的要求，无脑的使用，可能会带来很多致命的问题，但是可以通过严格的团队规范来避免。</p>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "monorepo"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/pnpmLearn/",
            "url": "https://zimu-66ccff.github.io/pnpmLearn/",
            "title": "为什么选择pnpm来替代npm，yarn",
            "date_published": "2023-10-31T08:51:37.000Z",
            "content_html": "<h1 id=\"npm-yarn-遇到了什么问腿\"><a class=\"anchor\" href=\"#npm-yarn-遇到了什么问腿\">#</a> npm, yarn, 遇到了什么问腿？</h1>\n<p>为了得到这个问题的答案，我们需要对 npm，yarn 执行 <code>npm install</code>  or  <code>yarn install</code>  后，在 <code>node_modules</code>  文件夹里面是怎么管理依赖的。</p>\n<h2 id=\"npm3-版本之前对依赖的管理\"><a class=\"anchor\" href=\"#npm3-版本之前对依赖的管理\">#</a> npm3 版本之前对依赖的管理</h2>\n<p>npm3 版本之前在生成的 <code>node_modules</code>  文件夹对依赖的管理是<ins>嵌套结构</ins>的</p>\n<p>假设我们有一个项目，它依赖于  <code>b</code>  包， <code>c </code> 包， <code>b</code>  包又依赖于  <code>d</code>  包和  <code>f</code>  包，  <code>c</code>  包又依赖于  <code>d</code>  包和  <code>f</code>  包<br />\n依赖关系如下：<br />\n<img data-src=\"https://i0.imgs.ovh/2023/10/31/AIEns.png\" alt=\"pnpmLearn01.png\" /></p>\n<p>当我们运行 <code>npm install</code>  的时候，生成的 <code>node_modules</code>  文件夹中对依赖的管理会是嵌套结构的，如下：</p>\n<pre><code>node_modules\n├── b\n|   └── node_modules\n|       └── d\n|       └── f\n├── c\n|   └── node_modules\n|       └── d\n|       └── e\n</code></pre>\n<p>我们可以发现，是和依赖关系对应的嵌套结构</p>\n<h2 id=\"npm3-版本之前对依赖的管理方式嵌套式的-node_modules-文件结构的缺陷\"><a class=\"anchor\" href=\"#npm3-版本之前对依赖的管理方式嵌套式的-node_modules-文件结构的缺陷\">#</a> npm3 版本之前对依赖的管理方式：嵌套式的 node_modules 文件结构的缺陷</h2>\n<ol>\n<li>嵌套的可能会非常深，就像  <code>d</code>  又依赖于  <code>d1</code> ， <code>d1</code>  又依赖于  <code>d2</code> ， <code>d2</code>  又依赖于  <code>d3</code> , 如此下去，嵌套的就会非常深，有的操作系统可能就难以支持了</li>\n<li>同一个项目里会出现依赖重复安装，我们可以看到 d 包是被安装了两次的，在 b 包的 <code>node_modules</code>  里被安装了一次，在 <code>c</code>  包的 <code>node_nodules</code>  又被重复安装了一次</li>\n<li>不同的项目里都依赖同一个依赖的时候，这个依赖在磁盘里会被重复安装。比如 <code>x</code>  项目和 <code>y</code>  项目都依赖于 <code>z</code>  包，那么 <code>z</code>  包就会在磁盘里被安装两次</li>\n</ol>\n<h2 id=\"npm3-版本之后和-yarn-对依赖的管理\"><a class=\"anchor\" href=\"#npm3-版本之后和-yarn-对依赖的管理\">#</a> npm3 版本之后和 yarn 对依赖的管理</h2>\n<p>npm3 以后的版本和 yarn 生成的 <code>node_modules</code>  文件夹是<ins>扁平结构的</ins><br />\n根据我们上面的项目例子，它的 <code>node_modules</code>  文件夹结构应该是如下的：</p>\n<pre><code>node_modules\n├── b\n├── c\n├── d\n├── f\n└── e\n\n</code></pre>\n<p>我们可以发现所有的依赖都被拍平了，是扁平化的，都被提升到了 node_modules 文件夹下面，而不是嵌套的。</p>\n<h2 id=\"npm3-版本之后和-yarn-对依赖的管理方式扁平式的-node_modules-文件结构-解决了之前的哪些问题\"><a class=\"anchor\" href=\"#npm3-版本之后和-yarn-对依赖的管理方式扁平式的-node_modules-文件结构-解决了之前的哪些问题\">#</a> npm3 版本之后和 yarn 对依赖的管理方式：扁平式的 node_modules 文件结构 解决了之前的哪些问题</h2>\n<ol>\n<li>解决了嵌套的非常深的问题<br />\n采用了扁平式的结构，完全不存在嵌套</li>\n<li>解决了同一个项目里依赖重复安装的问题<br />\n我们可以看到 <code>d包</code> 在 <code>node_modules</code>  文件夹下面是只安装了一次的。<br />\n那么 <code>b包</code>  or  <code>c包</code> 包要怎么找到他们依赖的 <code>d</code>  包呢，因为他们自己目录下没有 <code>node_modules</code> ，就会到上层目录里找 <code>node_modules</code> ，就可以找到项目根目录下面的 <code>node_modules</code> ，里面就有他们需要的 <code>d</code>  包<br />\n<ins> ps：依赖的查找方式是先在自己包目录下的 node_modules 目录下面找，如果不存在 or 没找到，就到上层目录的 node_modules 目录找，以此方式，不断的往上找</ins></li>\n</ol>\n<h2 id=\"npm3-版本之后-和-yarn-对依赖的管理方式扁平式的-node_modules-文件结构-带来了哪些新的问题-还存在哪些问题\"><a class=\"anchor\" href=\"#npm3-版本之后-和-yarn-对依赖的管理方式扁平式的-node_modules-文件结构-带来了哪些新的问题-还存在哪些问题\">#</a> npm3 版本之后 和 yarn 对依赖的管理方式：扁平式的 node_modules 文件结构 带来了哪些新的问题，还存在哪些问题</h2>\n<ul>\n<li>带来的新的问题\n<ol>\n<li>带了了 <code>幽灵依赖的问题</code>\n<ul>\n<li>什么是幽灵依赖<br />\n在我们上面的例子里，我们项目 <code>a</code>  只依赖于 <code>b</code>  和 <code>c</code> ，也就是说 <code>package.json</code>  里的 <code>dependencies</code>  只声明了 <code>b</code>  和 <code>c</code> ，但是因为扁平化的结构，我们可以在项目里使用 <code>package.json</code>  的 <code>dependencies</code>  里没有声明的 <code>d</code> ,  <code>e</code> ,  <code>f</code> 。 <code>d</code> ,  <code>e</code> ,  <code>f</code>  这三个依赖没有在项目目录的 <code>package.json</code>  里声明，但是却可以使用，这种依赖就被称为 <code>幽灵依赖</code></li>\n<li><code>幽灵依赖</code> 会造成什么后果<br />\n <code>d</code>  是被 <code>b</code>  依赖的，然后因为 <code>扁平化</code> 的结构，我们才能使用，那么如果有一天 <code>b</code>  不在依赖于 <code>d</code>  了，那么我们一旦 <code>npm install</code> ， <code>node_modules</code>  里就不会再有 <code>d</code>  了，而我们的项目代码还在使用 <code>d</code> ，那么马上就会报错</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>之前存在但是没有得到解决的问题\n<ol>\n<li>不同的项目里都依赖同一个依赖的时候，这个依赖在磁盘里会被重复安装。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"为什么选择-pnpmpnpm-的优势\"><a class=\"anchor\" href=\"#为什么选择-pnpmpnpm-的优势\">#</a> 为什么选择 pnpm（pnpm 的优势）</h1>\n<h2 id=\"pnpm-对依赖的管理\"><a class=\"anchor\" href=\"#pnpm-对依赖的管理\">#</a> pnpm 对依赖的管理</h2>\n<p>pnpm 对依赖的管理是一种扁平式和嵌套式相结合的，利用了软连接和硬链接的一种结构</p>\n<p><ins>ps: 这里简单的讲解一下什么是软连接，什么是硬链接</ins></p>\n<ul>\n<li>硬链接<br />\n在操作系统的文件系统里，磁盘的文件都会有一个编号叫索引节点号 (Inode Index)， 而硬链接就是文件名直接指向这个索引号，从而找到磁盘里的文件内容。并且可以存在多个文件硬链接同一个索引节点号。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</li>\n<li>软连接<br />\n软连接也叫符号链接，它是一个保存有其他文件位置信息的文件，指向的是其他文件的位置信息，而不是磁盘里的文件的索引节点号。所以一旦它指向的那个文件被删除，它就找不到了</li>\n<li>详细的讲解请看这篇文章<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaXRlY2gvYXJjaGl2ZS8yMDA5LzA0LzEwLzE0MzMwNTIuaHRtbA==\"> Linux 软连接和硬链接</span></li>\n</ul>\n<p>依旧是我们上面的例子，它的 <code>node_modules</code>  文件夹结构应该是如下的：</p>\n<pre><code>node_modules\n├── .pnpm\n    └── b // 硬连接 指向的是磁盘里的b包\n        └── node_modules\n            └── d // 软连接 指向的是 .pnpm/d\n            └── f // 软连接 指向的是 .pnpm/f\n    └── c\n        └── node_modules\n            └── d // 软连接 指向的是 .pnpm/d\n            └── e // 软连接 指向的是 .pnpm/e\n    └── d // 硬连接 指向的是磁盘里的d包\n    └── e // 硬连接 指向的是磁盘里的e包\n    └── f // 硬连接 指向的是磁盘里的f包\n    └── node_modules\n        └── b // 软连接 指向的是.pnpm/b\n        └── c // 软连接 指向的是.pnpm/c\n        └── d // 软连接 指向的是.pnpm/d\n        └── e // 软连接 指向的是.pnpm/e\n        └── f // 软连接 指向的是.pnpm/f\n├── b // 软连接 指向的是 .pnpm/b\n├── c // 软连接 指向的是 .pnpm/c\n</code></pre>\n<p>看到这个文件结构的时候第一感觉肯定是，好复杂啊，一下子多了好多东西，没关系，我接下来会逐一介绍为什么会是这样的，然后你就会发现这个结构真的是十分巧妙</p>\n<ul>\n<li>\n<p>node_modules</p>\n<ol>\n<li>\n<p>我们会发现 <code>node_modules</code>  目录下的包文件和我们项目里的 <code>package.json</code>  里 <code>dependencies</code>  声明的包是一摸一样的。这样就可以有效的避免 <code>幽灵依赖的问题</code> ，项目里就不能直接使用 <code>d</code> ,  <code>e</code>  , <code>f</code>  这些幽灵依赖了，因为 <code>node_modules</code>  里面没有。<ins>完美解决幽灵依赖的问题</ins></p>\n</li>\n<li>\n<p>好，聪明的你马上就会问， <code>b</code> ,  <code>c</code>  都有各自的依赖呀，可是 <code>node_modules/b</code> , <code>node_modules/c</code>  里面没有 <code>node_modules</code>  呀，那怎么找到他们的依赖呢。那么现在就告诉你真相， <code>node_modules/</code>  下面的包文件全部都是 <code>软连接</code> ，他们都指向 <code>node_modules/.pnpm/</code>  目录下 对应的包，也就是 <code>node_modules/.pnpm/b</code> ，  <code>node_modules/.pnpm/c</code> , 他们下面就有对应的 <code>node_modules</code>  来存储他们各自对应的依赖啦。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>node_modules/.pnpm</p>\n<ol>\n<li>我们会发现 <code>node_modules/.pnpm</code>  目录下拥有着我们项目所有的依赖， <code>b</code> ,  <code>c</code> ,  <code>d</code>  , <code>e</code> ,  <code>f</code> ，并且是扁平化的，而且他们都是 <code>硬链接</code> 。都指向磁盘里的 <code>b</code> ， <code>c</code> ， <code>d</code> ,  <code>e</code>  , <code>f</code> 。这样当我们在其他项目里面也有这些依赖的时候，就不需要在磁盘里面重复安装，直接一个 <code>硬连接</code> 指向磁盘里对应的文件就可以。<ins>完美解决不同项目里同样的依赖在磁盘里重复安装的问题</ins></li>\n</ol>\n</li>\n<li>\n<p>node_modules/.pnpm/ 包文件 /node_modules</p>\n<ol>\n<li>我们会发现 <code>node_modules/.pnpm/包文件/node_modules/</code>  目录下拥有者包所需要的依赖， 而这些依赖其实都是软连接，指向 <code>node_modules/.pnpm</code>  目录下对应的包文件。在这里就是 <code>node_modules/.pnpm/b/</code>  下面有着 <code>d</code> ,  <code>f</code> , 但其实这个 <code>d</code> ,  <code>f</code>  都是软连接，指向 <code>node_modules/.pnpm/d</code> ,  <code>node_modules/.pnpm/f</code> 。这样虽然 <code>b</code> ,  <code>c</code>  都依赖于 <code>d</code> , 但是却不会重复安装，而是都指向 <code>node_modules/.pnpm/d</code> 。 <ins>完美解决同一项目里依赖重复安装的问题</ins></li>\n</ol>\n</li>\n<li>\n<p>node_modules/.pnpm/node_modules</p>\n<ol>\n<li>我们会发现 <code>node_modules/.pnpm/node_modules</code>  这个目录下存有项目的所有依赖。当然，都是软连接，指向 <code>node_modules/.pnpm</code>  下面的包，那么这个文件夹到底是什么作用呢。</li>\n<li>我们都知道 <code>幽灵依赖</code> 是不安全的，是很容易导致问题的，但是现实是，依旧很多第三方包使用了幽灵依赖，而我们的 pnpm 也对幽灵依赖做了兼容，在特定的情况下是允许幽灵依赖的，那么幽灵依赖在哪找呢，就是这个目录下面，这个目录是扁平化的，拥有项目所有的包。 <ins>实现了对幽灵依赖的支持 但是最好不要这样 因为幽灵依赖并不安全</ins></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"pnpm-的优势解决了哪些问题\"><a class=\"anchor\" href=\"#pnpm-的优势解决了哪些问题\">#</a> pnpm 的优势，解决了哪些问题</h2>\n<ol>\n<li>通过软连接避免了 <code>幽灵依赖</code> 的问题</li>\n<li>通过硬连接解决了 <code>不同项目的相同依赖</code> 在磁盘重复安装的问题，提升了速度</li>\n<li>通过软连接，  <code>node_modules/.pnpm</code>  的 <code>扁平化</code> 结构解决了 <code>同一项目里相同依赖</code> 重复安装的问题</li>\n<li>通过软连接和 <code>node_modules/.pnpm/node_modules</code>  目录，兼容了 <code>幽灵依赖</code></li>\n</ol>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "pnpm",
                "包管理器"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/plopLearn/",
            "url": "https://zimu-66ccff.github.io/plopLearn/",
            "title": "plop-一个基于模板的代码生成器",
            "date_published": "2023-10-29T09:53:34.000Z",
            "content_html": "<h1 id=\"plop-是什么为什么需要-plop\"><a class=\"anchor\" href=\"#plop-是什么为什么需要-plop\">#</a> plop 是什么，为什么需要 plop</h1>\n<p>Plop is a little tool that saves you time and helps your team build new files with consistency.<br />\n 这是官网对于 plop 的评价，实际上也确实是这样， plop 可以通过命令和用户配置的 hbs 模板文件来在指定的目录下生成对应的模板代码。想一想，我们只需要通过一个命令，就可以在我们需要的目录下生成对应的文件，里面有本来需要我们手写的结构代码，这该是一件多爽的事情，可以大大的节约我们的时间</p>\n<h1 id=\"plop-体验\"><a class=\"anchor\" href=\"#plop-体验\">#</a> plop 体验</h1>\n<h2 id=\"下载-plop推荐全局下载\"><a class=\"anchor\" href=\"#下载-plop推荐全局下载\">#</a> 下载 plop (推荐全局下载)</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">pnpm</span> <span class=\"token function\">install</span> plop <span class=\"token parameter variable\">-g</span></pre></td></tr></table></figure><h2 id=\"编写模板代码\"><a class=\"anchor\" href=\"#编写模板代码\">#</a> 编写模板代码</h2>\n<pre><code>&lt;!-- templates/sfc/index.vue.hbs --&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\n&#123;&#123;> importVueRef&#125;&#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div class=&quot;&#123;&#123;componentName&#125;&#125;&quot;&gt;&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped lang=&quot;less&quot;&gt;\n.&#123;&#123;componentName&#125;&#125;\n&#123;&#125;\n&lt;/style&gt;\n</code></pre>\n<p>在根目录下新建一个文件夹存放我们对应的模板代码，plop 后面会根据这些模板代码来生成我们需要的代码</p>\n<p>你可能已经发现了出现了 <code>&#123;&#123;componentName&#125;&#125;</code>  这样的代码  <code>&#123;&#123;&#125;&#125;</code>  这个叫模板语法，你可能会说这不是和 vue 的模板语法是一样的嘛 是的 是一样的 因为 vue 的模板语法就是借鉴（抄）的这个 那么你应该会好奇 componentName 的值是什么呢 这个将会在命令里传递 请继续往下看</p>\n<h3 id=\"在项目根目录创建我们的-plopfilejs-文件\"><a class=\"anchor\" href=\"#在项目根目录创建我们的-plopfilejs-文件\">#</a> 在项目根目录创建我们的 plopfile.js 文件</h3>\n<pre><code>export default function (plop) &#123;\n  plop.setGenerator('createSFC', &#123;\n    description: 'create one SFC',\n    prompts: [&#123; type: 'input', name: 'componentName', message: 'input componentName' &#125;],\n    actions: (data) =&gt; &#123;\n      return [\n        &#123;\n          type: 'add',\n          path: './src/&#123;&#123;camelCase componentName&#125;&#125;/index.vue',\n          templateFile: './templates/sfc/index.vue.hbs',\n        &#125;,\n      ];\n    &#125;,\n  &#125;);\n  plop.setPartial('importVueRef', `import &#123;Ref&#125; from 'vue' `);\n&#125;\n</code></pre>\n<p>简单讲解一下，我们用 <code>plop</code>  这个对象身上的 <code>setGenerator</code>  命令，配置了一个命令， <code>createSFC</code>  是这个命令的名字（自己取），然后通过终端输入 <code>plop createSFC</code>  这个命令来使用。<br />\n <code>description</code>  是对这个命令功能的描述，当我们输入 <code>plop</code>  命令的时候，终端会列出所有的 plop 命令和它的描述（就是我们这里 description 写的）.<br />\n <code>prompts</code>  是一个数组，数组里面的元素是一个对象（用来描述终端提示语的）</p>\n<ul>\n<li>type<br />\n 这个提示的类型，这里是 'input',</li>\n<li>name<br />\n 定义变量名 (这里的变量名是 componentName)，用来存储用户将从终端输入的值 (因为是 input 类型，所以是用户输入一个值)。</li>\n<li>message<br />\n 提示信息</li>\n</ul>\n<p><code>action</code>  是这个命令具体将执行的操作，是一个数组，因为一个命令是可以执行多个操作的。</p>\n<ul>\n<li>type<br />\n 操作的类型，这里是 'add', 也就是在指定目录下生成一个文件</li>\n<li>path<br />\n 生成的文件的路径， <code>'./src/&#123;&#123;camelCase componentName&#125;&#125;/index.vue'</code> ， 这里又出现了插值语法， <code>componentName</code>  是我们在 <code>prompts</code>  里面配置的用户输入的，我们假设输入的是 'button-success'， 你可能注意到了前面还有一个 <code>camelCase</code> ，这个是一个 <code>helper</code> ，它的作用是把 componentName 的值变成驼峰形式，也就是说用户输入的 'button-success' 会变成 'buttonSuccess'。也就是说实际上生成的文件路径会是 <code>./src/buttonSuccess/index.vue</code> 。</li>\n<li>templateFile<br />\n 我们写的模板代码，也就是 hbs 文件的路径，在这里就是生成的 <code>index.vue</code>  文件的代码将会是这个 <code>'./templates/sfc/index.vue.hbs'</code>  文件里的代码</li>\n</ul>\n<h2 id=\"在-packagejson-文件的-script-里面配置脚本\"><a class=\"anchor\" href=\"#在-packagejson-文件的-script-里面配置脚本\">#</a> 在 package.json 文件的 script 里面配置脚本</h2>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token property\">\"plop\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"plop\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"执行命令\"><a class=\"anchor\" href=\"#执行命令\">#</a> 执行命令</h2>\n<ol>\n<li>执行 <code>pnpm plop</code>  命令<br />\n<img data-src=\"https://i0.imgs.ovh/2023/10/29/AVTPm.png\" alt=\"plopLearn01.png\" /></li>\n<li>输入 <code>componentName</code> <br />\n<img data-src=\"https://i0.imgs.ovh/2023/10/29/AVq6N.png\" alt=\"plopLearn02.png\" /></li>\n<li>src/buttonSuccess 目录下就生成了 index.vue 代码了</li>\n<li>查看 src/buttonSuccess/index.vue 的代码<br />\n<img data-src=\"https://i0.imgs.ovh/2023/10/29/AVGGp.png\" alt=\"plop03.png\" /><br />\n 我们可以发现和我们的模板代码 hbs 文件几乎是一样的，并且 <code>&#123;&#123;componentName&#125;&#125;</code>  这种插值语法也已经被正确的替换为了用户输入的 <code>buttonSucess</code>  (用户输入的 button-success， 但是被我们设置的 camelCase 给转化成了驼峰形式)</li>\n</ol>\n<h1 id=\"plop-的-api-讲解\"><a class=\"anchor\" href=\"#plop-的-api-讲解\">#</a> plop 的 api 讲解</h1>\n<h2 id=\"sethelper\"><a class=\"anchor\" href=\"#sethelper\">#</a> setHelper</h2>\n<p>用来自定义 <code>helper</code> ,  <code>helper</code>  用来对值做转换，例如:</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">plop</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  plop<span class=\"token punctuation\">.</span><span class=\"token function\">setHelper</span><span class=\"token punctuation\">(</span><span class=\"token string\">'upperCase'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">text</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> text<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>第一个参数为 helper 的名字，这里是 &quot;upperCase&quot;, 第二个参数为处理函数，这里是将值转换为大写</p>\n<ul>\n<li>\n<p>使用方式:</p>\n<pre><code>&#123;&#123;upperCase componentName&#125;&#125;\n</code></pre>\n</li>\n<li>\n<p>效果：<br />\n假设 componentName 本来的值是 &quot;button&quot;， 那么它最终会被转换成 'BUTTON'</p>\n</li>\n<li>\n<p>自带的 helper（这些 helper 为 plop 自带的，可以直接使用）：</p>\n<ul>\n<li>camelCase: changeFormatToThis</li>\n<li>snakeCase: change_format_to_this</li>\n<li>dashCase/kebabCase: change-format-to-this</li>\n<li>dotCase: change.format.to.this</li>\n<li>pathCase: change/format/to/this</li>\n<li>properCase/pascalCase: ChangeFormatToThis</li>\n<li>lowerCase: change format to this</li>\n<li>sentenceCase: Change format to this,</li>\n<li>constantCase: CHANGE_FORMAT_TO_THIS</li>\n<li>titleCase: Change Format To This</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"setpartial\"><a class=\"anchor\" href=\"#setpartial\">#</a> setPartial</h2>\n<p>用来自定义局部的模板，例如：</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">/** @type &#123;import('plop').NodePlopAPI&#125; */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  plop</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  plop<span class=\"token punctuation\">.</span><span class=\"token function\">setPartial</span><span class=\"token punctuation\">(</span><span class=\"token string\">'importVueRef'</span><span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">import &#123;Ref&#125; from 'vue' </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>第一个参数为局部模板的名字，这里是 'importVueRef', 第二个人参数为模板，这里是 'import {Ref} from 'vue'</p>\n<ul>\n<li>使用方式：</li>\n</ul>\n<pre><code>&#123;&#123;> importVueRef&#125;&#125;\n</code></pre>\n<ul>\n<li>效果：<br />\n <code>&#123;&#123;> importVueRef&#125;&#125;</code>  会变成  <code>import &#123;Ref&#125; from 'vue</code></li>\n</ul>\n<h1 id=\"内置的-actions-type\"><a class=\"anchor\" href=\"#内置的-actions-type\">#</a> 内置的 actions type</h1>\n<h2 id=\"add\"><a class=\"anchor\" href=\"#add\">#</a> add</h2>\n<p>用来在指定的路径生成文件</p>\n<ul>\n<li>常用属性（其他属性请查官网）\n<ul>\n<li>path<br />\nstring 类型，生成的文件的路径</li>\n<li>template<br />\nstring 类型，模板，以这个模板来生成文件（说白点，就是生成的文件的代码会和这个模板一摸一样）</li>\n<li>templateFile<br />\nstring 类型，模板代码文件的路径，会以这个路径的模板文件来生成文件</li>\n<li>force<br />\nboolean 类型，当该文件已经存在的时候，是否覆盖</li>\n<li>data<br />\n 对象或者函数类型（函数要返回一个对象），为模板提供额外的数据（就是为那些插值语法提供额外的数据）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"addmany\"><a class=\"anchor\" href=\"#addmany\">#</a> addMany</h2>\n<p>将多个目录和文件添加到指定目录</p>\n<ul>\n<li>常用属性（其他属性请查官网）\n<ul>\n<li>destination<br />\nstring 类型，在该路径下添加文件</li>\n<li>base<br />\nstring 类型， 在该路径下匹配目录和文件，匹配到的目录和文件将会被添加到对应路径下面</li>\n<li>templateFiles<br />\nglob 类型， 以该模式匹配目录和文件的模式， 比如 templates/components/*, 就是匹配 templates 目录下的 components 目录下的所有文件</li>\n<li>stripExtensions<br />\n 添加到指定目录时自动删掉对应的后缀名，默认值为 ['hbs']， 也就是说添加文件的时候.hbs 后缀会被默认删掉。比如说文件名为 index.vue.hbs, 添加的时候就会变成 index.vue</li>\n<li>force<br />\nboolean 类型，当该文件已经存在的时候，是否覆盖</li>\n<li>data<br />\n 对象或者函数类型（函数要返回一个对象），为模板提供额外的数据（就是为那些插值语法提供额外的数据）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"modify\"><a class=\"anchor\" href=\"#modify\">#</a> modify</h2>\n<p>用于替换指定文件中的匹配到的文本</p>\n<ul>\n<li>常用属性（其他属性请查官网）\n<ul>\n<li>path<br />\n 同上</li>\n<li>pattern<br />\n 正则表达式，用于匹配文本</li>\n<li>template<br />\nstring 类型，用于将匹配到的文本替换成这个模板</li>\n<li>templateFile<br />\nstring 类型， 模板的路径，以该路径的模板来替换匹配到的文本</li>\n<li>transform<br />\n 函数类型，用来转换文件内容</li>\n<li>data<br />\n 同上</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"append\"><a class=\"anchor\" href=\"#append\">#</a> append</h2>\n<p>用于在指定文件中匹配到的文本后面添加内容</p>\n<ul>\n<li>常用属性（其他属性请查官网）\n<ul>\n<li>path<br />\n 同上</li>\n<li>pattern<br />\n 正则表达式，用于匹配文本</li>\n<li>template<br />\nstring 类型，用于在匹配到的文本后面添加这个模板</li>\n<li>templateFile<br />\nstring 类型， 模板的路径，将该路径的模板添加到匹配到的文本后面</li>\n<li>transform<br />\n 函数类型，用来转换文件内容</li>\n<li>data<br />\n 同上</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"内置的-promps-type\"><a class=\"anchor\" href=\"#内置的-promps-type\">#</a> 内置的 promps type</h2>\n<p>和 inquire 的一样 详细的可以查看 inquire 的官网<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NCb3Vkcmlhcy9JbnF1aXJlci5qcw==\"> https://github.com/SBoudrias/Inquirer.js</span></p>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "plop",
                "脚手架"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/packageJsonLearn/",
            "url": "https://zimu-66ccff.github.io/packageJsonLearn/",
            "title": "package.json文件详解",
            "date_published": "2023-10-28T06:56:50.000Z",
            "content_html": "<h1 id=\"packagejson-是什么\"><a class=\"anchor\" href=\"#packagejson-是什么\">#</a> package.json 是什么</h1>\n<p><code>package.json</code>  文件会描述我们项目的所有配置信息（名称，版本，使用协议），所有 npm 包的信息（版本，是否是开发环境依赖）</p>\n<h1 id=\"怎么创建-packagejson-文件\"><a class=\"anchor\" href=\"#怎么创建-packagejson-文件\">#</a> 怎么创建 package.json 文件</h1>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># npm</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">npm</span> init</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># pnpm</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">pnpm</span> init</pre></td></tr></table></figure><h1 id=\"属性介绍\"><a class=\"anchor\" href=\"#属性介绍\">#</a> 属性介绍</h1>\n<h2 id=\"name\"><a class=\"anchor\" href=\"#name\">#</a> name</h2>\n<p>包的名字， 不能以 <code>.</code> ,  <code>_</code> ,  <code>大写字母</code> 开头</p>\n<ul>\n<li>\n<p>npm 域级包</p>\n<ul>\n<li>\n<p>介绍及其作用<br />\n在 npm 的包管理系统中，有一种  <code>scoped packages</code>  机制，用于将一些 npm 包以 <code>@scope/package</code>  的命名形式集中在一个命名空间下面，实现域级的包管理。域级包不仅不用担心会和别人的包名重复，同时也能对功能类似的包进行统一的划分和管理；比如我们用 vue 脚手架搭建的项目，里面就有 <code>@vue/cli-plugin-babel</code> 、 <code>@vue/cli-plugin-eslint</code>  等等域级包。相同域级范围内的包会被安装在相同的文件路径下，比如 <code>node_modules/@username/</code> ，可以包含任意数量的作用域包；安装域级包也需要指明其作用域范围：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> @username/package</pre></td></tr></table></figure></li>\n<li>\n<p>我们在初始化项目时可以使用命令行来添加  <code>scope</code> ：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">npm</span> init <span class=\"token parameter variable\">--scope</span><span class=\"token operator\">=</span>username</pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"version\"><a class=\"anchor\" href=\"#version\">#</a> version</h2>\n<p>包的版本号，npm 包的版本号也是有规范要求的，通用的就是遵循  <code>semver</code>  语义化版本规范，版本格式为： <code>major.minor.patch</code> ，每个字母代表的含义如下：</p>\n<ul>\n<li>\n<p>主版本号 (major)：当你做了不兼容的 API 修改</p>\n</li>\n<li>\n<p>次版本号 (minor)：当你做了向下兼容的功能性新增</p>\n</li>\n<li>\n<p>修订号 (patch)：当你做了向下兼容的问题修正</p>\n</li>\n<li>\n<p>先行版本号：先行版本号是加到修订号的后面，作为版本号的延伸；当要发行大版本或核心功能时，但不能保证这个版本完全正常，就要先发一个先行版本。</p>\n<ul>\n<li>\n<p>格式<br />\n先行版本号的格式是在修订版本号后面加上一个连接号（-），再加上一连串以点（.）分割的标识符，标识符可以由英文、数字和连接号（[0-9A-Za-z-]）组成。例如：</p>\n<pre><code>1.0​​.0-alpha\n1.0.0-alpha.1\n1.0.0-0.3.7\n</code></pre>\n</li>\n<li>\n<p>常见先行版本号</p>\n<ul>\n<li>alpha：不稳定版本，一般而言，该版本的 Bug 较多，需要继续修改，是测试版本</li>\n<li>beta：基本稳定，相对于 Alpha 版已经有了很大的进步，消除了严重错误</li>\n<li>rc：和正式版基本相同，基本上不存在导致错误的 Bug</li>\n<li>release：最终版本</li>\n</ul>\n<div class=\"note info\">\n<p>当主版本号升级后，次版本号和修订号需要重置为 0，次版本号进行升级后，修订版本需要重置为 0。</p>\n</div>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"description-keywords\"><a class=\"anchor\" href=\"#description-keywords\">#</a> description, keywords</h2>\n<ul>\n<li>description<br />\n <code>String</code>  类型，描述项目的信息， 可以显示在 <code>npm search</code>  命令的返回结果中</li>\n<li>keywords<br />\nArray <code>类型， 描述项目的信息， 可以显示在</code>  npm search` 命令的返回结果中</li>\n</ul>\n<h2 id=\"homepage\"><a class=\"anchor\" href=\"#homepage\">#</a> homepage</h2>\n<p>用来指定项目的主页 or 部署网站的根目录。</p>\n<ul>\n<li>\n<p>开发环境的作用</p>\n<ul>\n<li>\n<p>避免路径问题</p>\n<p>一些前端框架和构建工具在路由和资源加载时依赖于  <code>homepage</code>  属性。如果你不在开发环境中设置  <code>homepage</code> ，可能会在构建应用时遇到问题，尤其是当你使用前端路由（如  <code>React Router</code> ）时。</p>\n</li>\n<li>\n<p>测试相对路径:</p>\n<p>开发环境中的开发服务器通常使用相对路径来加载资源，而不需要指定完整的 URL。设置  <code>homepage</code>  属性可以帮助你测试应用在不同路径上的行为，以确保它在生产环境中正常工作。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>生产环境的作用<br />\n指定应用程序的根 URL，确保所有资源（例如 CSS、JavaScript 文件等）的加载路径正确。这是非常关键的，因为在生产环境中，你的应用可能托管在不同的域名、子目录或路径上，而  <code>homepage</code>  可以确保资源正确加载。</p>\n</li>\n</ul>\n<h2 id=\"author-contributors-maintainers\"><a class=\"anchor\" href=\"#author-contributors-maintainers\">#</a> author, contributors, maintainers</h2>\n<ul>\n<li>author<br />\n 作者， <code>string | &#123;name: string, url?: sting, email?: string&#125;</code>  类型</li>\n<li>contributors<br />\n 贡献者列表，  <code>Array&lt;string | &#123;name: string, url?: sting, email?: string&#125;&gt;</code>  类型</li>\n<li>maintainers<br />\n 维护者列表， <code>Array&lt;string | &#123;name: string, url?: sting, email?: string&#125;&gt;</code>  类型</li>\n</ul>\n<h2 id=\"bugs\"><a class=\"anchor\" href=\"#bugs\">#</a> bugs</h2>\n<p>提供地址来让用户反馈存在的问题， <code>&#123;url: string, email: string&#125;</code>  类型</p>\n<h2 id=\"license-license\"><a class=\"anchor\" href=\"#license-license\">#</a> license, license</h2>\n<ul>\n<li>license<br />\n 开源协议名称， <code>string</code>  类型</li>\n<li>licenses<br />\n 多个包的开源协议名称， <code>Array&lt;&#123;type: string, url: string&#125;&gt;</code>  类型<br />\n<img data-src=\"https://i0.imgs.ovh/2023/10/28/FDPvK.png\" alt=\"license.png\" /></li>\n</ul>\n<h2 id=\"main-module-browser\"><a class=\"anchor\" href=\"#main-module-browser\">#</a> main, module, browser</h2>\n<ul>\n<li>main<br />\n 指定加载时的入口文件， <code>cmd</code>  模块规范导入的时候就会加载这个文件，默认为根目录下的 <code>index.js</code>  文件，  <code>browser</code>  和 <code>node</code>  环境下均可使用， <code>string</code>  类型</li>\n<li>module<br />\n 指定 <code>esm</code>  模块规范时的入口文件， <code>browser</code>  和 <code>node</code>  环境下均可使用， <code>string</code>  类型</li>\n<li>browser<br />\n 指定 <code>browser</code>  环境下的入口文件</li>\n</ul>\n<h2 id=\"dependencies-devdependencies\"><a class=\"anchor\" href=\"#dependencies-devdependencies\">#</a> dependencies, devDependencies</h2>\n<ul>\n<li>\n<p>dependencies<br />\n 项目 <code>运行</code> 所需的依赖， <code>开发</code> 和 <code>生产</code> 环境都需要的依赖，命令如下:</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 不缩写</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> xxx <span class=\"token parameter variable\">--save</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 缩写</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> xxx <span class=\"token parameter variable\">-S</span></pre></td></tr></table></figure></li>\n<li>\n<p>devDependencies<br />\n 项目 <code>开发</code> 所需的依赖，只会在 <code>开发</code> 环境被安装，命令如下：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 不缩写</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> xxx --save-dev</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 缩写</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> xxx <span class=\"token parameter variable\">-D</span></pre></td></tr></table></figure><ul>\n<li>\n<p>版本号规则：</p>\n<ul>\n<li>没有任何符号：完全百分百匹配，必须使用当前版本号</li>\n<li>对比符号类的：&gt;(大于) &gt;=(大于等于) &lt;(小于) &lt;=(小于等于)</li>\n<li>波浪符号<sub>：固定主版本号和次版本号，修订号可以随意更改，例如</sub> 2.0.0，可以使 用 2.0.0、2.0.2 、2.0.9 的版本。</li>\n<li>插入符号<sup>：固定主版本号，次版本号和修订号可以随意更改，例如</sup> 2.0.0，可以使 用 2.0.1、2.2.2 、2.9.9 的版本。</li>\n<li>任意版本 *：对版本没有限制，一般不用</li>\n<li>或符号：|| 可以用来设置多个版本号限制规则，例如 &gt;= 3.0.0 || &lt;= 1.0.0</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"peerdependencies-bundleddependencies-optionaldependencies\"><a class=\"anchor\" href=\"#peerdependencies-bundleddependencies-optionaldependencies\">#</a> peerDependencies, bundledDependencies, optionalDependencies</h2>\n<ul>\n<li>\n<p>peerDependencies<br />\n 用来告诉别人当使用这个依赖的时候，需要使用那些特定版本的依赖，比如 <code>依赖 A</code>  的  <code>package.json</code>  中声明了  <code>peerDependencies</code> ,  <code>xxx6.0</code>  吗，那么如果安装了 <code>依赖 A</code>  就也应该安装  <code>xxx6.0</code></p>\n<div class=\"note info\">\n<p>但是请注意， <code>peerDependencies</code>  下的依赖并不会被强行安装，它只是告诉你，应该安装 对应版本的这些依赖，因为该依赖依赖于这些依赖，如果不安装，可能会出现问题</p>\n</div>\n</li>\n<li>\n<p>bundledDependencies</p>\n<p>依赖默认时不会被打包的，但是 <code>bundledDependencies</code>  下的依赖也会被一起打包</p>\n</li>\n<li>\n<p>optionalDependencies</p>\n<p>指定一些可选的依赖，这些依赖也会被 <code>npm install</code>  安装，但是安装失败了，不会报错，不会导致整个 <code>npm install</code>  失败</p>\n</li>\n</ul>\n<h2 id=\"files\"><a class=\"anchor\" href=\"#files\">#</a> files</h2>\n<p>用来指定 npm 发包时应该包括哪些目录和文件， <code>string | Array&lt;string&gt;</code>  类型</p>\n<h2 id=\"bin\"><a class=\"anchor\" href=\"#bin\">#</a> bin</h2>\n<p>用来指定命令和对应的可执行文件，例如：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"my-cli-tool\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token property\">\"bin\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token property\">\"my-command\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bin/my-command.js\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>bin</code>  中的键（例如  <code>&quot;my-command&quot;</code> ）是用户在命令行中执行的命令名称。 <code>bin</code>  中的值是指向模块中实际可执行文件的相对路径。当全局安装 <code>my-cli-tool</code>  的时候，系统会创建一个符号链接，将  <code>bin</code>  中指定的命令名称与相应的可执行文件关联，然后这个符号连接会被添加到系统的 <code>PATH</code>  变量中。当我们执行 <code>my-command</code>  命令的时候，系统就会通过 <code>PATH</code>  的符号连接找到对应的 <code>bin/my-command</code>  文件并执行其中的代码。如果我们的包以 <code>依赖</code> 的方式被安装时，如果有 <code>bin</code> ，就会在 <code>node_modules/.bin/</code>  生成对应的文件，然后建立符号链接，所有 <code>node_modules/.bin/</code>  目录下的命令都可以使用 <code>npm run [命令]</code>  的格式下运行。</p>\n<h2 id=\"directories\"><a class=\"anchor\" href=\"#directories\">#</a> directories</h2>\n<p>展示项目的目录结构信息，用来告诉用户每个目录在什么位置， 比如：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"my-module\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token property\">\"directories\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token property\">\"bin\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bin\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token property\">\"lib\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"src\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token property\">\"doc\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"docs\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>用来告诉用户 or 其他开发者 可执行文件请放到  <code>bin</code>  目录，库的核心代码请放到  <code>lib</code>  目录，文档代码请放到  <code>doc</code>  目录。</p>\n<h2 id=\"repository\"><a class=\"anchor\" href=\"#repository\">#</a> repository</h2>\n<p>用来告诉想要加入我们，对我们的代码做贡献的人，我们的代码仓库在哪里， <code>&#123;type: string, url: string, directory: string&#125;</code>  类型。比如：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token property\">\"repository\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"git\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://github.com/DomeSy\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token property\">\"directory\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"描述话语\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"script\"><a class=\"anchor\" href=\"#script\">#</a> script</h2>\n<p>指定对应命令的脚本（缩写）, 比如：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token property\">\"start\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"cross-env UMI_ENV=dev umi dev\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当执行 <code>npm run script</code>  的时候就相当于执行了 <code>cross-env UMI_ENV=dev umi dev</code></p>\n<h2 id=\"config\"><a class=\"anchor\" href=\"#config\">#</a> config</h2>\n<p>用来添加命令行的环境变量， 比如：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"domesy\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token property\">\"config\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token property\">\"port\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"8088\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token property\">\"script\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token property\">\"start\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"node server.js\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当我们在 node 环境中打印 <code>process.npm_package_config_port</code>  的时候就会打印出 8080</p>\n<h2 id=\"engines\"><a class=\"anchor\" href=\"#engines\">#</a> engines</h2>\n<p>用来指定本库的运行条件， 比如：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"engines\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token property\">\"node\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\">=0.10.3 &lt;0.12\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里就限制了，如果想要运行本库，node 的版本必须大于等于 0.10.3 小于 0.12</p>\n<h2 id=\"os\"><a class=\"anchor\" href=\"#os\">#</a> os</h2>\n<p>用来指定可以在哪些操作系统上运行，比如：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"os\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"linux\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"win64\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>就说明可以在 <code>linux</code>  和 <code>64位的windows</code>  操作系统上运行</p>\n<h2 id=\"cpu\"><a class=\"anchor\" href=\"#cpu\">#</a> cpu</h2>\n<p>用来指定可以在哪些架构下的 <code>cpu</code>  上运行， 比如:</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"cpu\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"x64\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ia32\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"private\"><a class=\"anchor\" href=\"#private\">#</a> private</h2>\n<p>用来指定这是否是一个私人的库，如果是，那么就不能在 npm 上面发布公开，  <code>boolean</code>  类型</p>\n<h2 id=\"publishconfig\"><a class=\"anchor\" href=\"#publishconfig\">#</a> publishConfig</h2>\n<p>用来指定发包时候的一些配置，比如发到哪个包管理服务器上面，是发布哪个版本，访问级别（哪些用户可以访问）比如：</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"publishConfig\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token property\">\"tag\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 发布 1.0.0 版本</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token property\">\"registry\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://www.npmjs.com/package/domesy-cli\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 发布到这个包管理服务器上面</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token property\">\"access\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"public\"</span> <span class=\"token comment\">// 所有用户都可以访问</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"preferglobal\"><a class=\"anchor\" href=\"#preferglobal\">#</a> preferGlobal</h2>\n<p>用来指定当用户不全局下载该库的时候是否发出警告，  <code>boolean</code>  类型</p>\n<h2 id=\"browserslist\"><a class=\"anchor\" href=\"#browserslist\">#</a> browserslist</h2>\n<p>指定该库支持的浏览器类型， 比如</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token property\">\"browserslist\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token property\">\"production\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\">0.2%\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"not dead\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"not op_mini all\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token property\">\"development\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"last 1 chrome version\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"last 1 firefox version\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"last 1 safari version\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "package.json文件"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/vite%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BE%97%E5%8A%9B%E5%8A%A9%E6%89%8B-esbuild-rollup/",
            "url": "https://zimu-66ccff.github.io/vite%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BE%97%E5%8A%9B%E5%8A%A9%E6%89%8B-esbuild-rollup/",
            "title": "vite的两个得力助手-esbuild-rollup",
            "date_published": "2023-07-26T09:47:06.000Z",
            "content_html": "<h1 id=\"esbuild\"><a class=\"anchor\" href=\"#esbuild\">#</a> esbuild</h1>\n<h3 id=\"esubuild-为什么快vite-选择-esbuild-在开发环境打包第三方依赖的原因\"><a class=\"anchor\" href=\"#esubuild-为什么快vite-选择-esbuild-在开发环境打包第三方依赖的原因\">#</a> esubuild 为什么快 (vite 选择 esbuild 在开发环境打包第三方依赖的原因)</h3>\n<ul>\n<li>使用 Go 开发<br />\n Go 的代码会被直接编译成原生机器码，而不需要像 JS 一样先解析为字节码，然后再转换成字节码，大大的节省了程序运行的时间、</li>\n<li>多核并行<br />\n因为 Go 中多线程共享内存的优势，内部打包算法充分的利用了多核 CPU 的多核优势，使得所有步骤尽可能的并行</li>\n<li>从零造轮子<br />\n几乎没有使用第三方库，全部是自己编写的逻辑，保证了代码的极致性能</li>\n<li>高效的内存利用<br />\n Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据（如 string -&gt; TS -&gt; JS -&gt; string)，造成内存的大量浪费。</li>\n</ul>\n<h3 id=\"esbuild-的不足vite-为什么在生产环境不选择-esbuild-而选择了-rollup-来进行打包\"><a class=\"anchor\" href=\"#esbuild-的不足vite-为什么在生产环境不选择-esbuild-而选择了-rollup-来进行打包\">#</a> esbuild 的不足（vite 为什么在生产环境不选择 esbuild 而选择了 rollup 来进行打包）</h3>\n<ul>\n<li>无法兼容低端浏览器<br />\n不支持把语法降级到 <code>es5</code> ，不支持 <code>const enum</code>  等高级语法</li>\n<li>无法灵活处理打包产物，无法自定义拆包<br />\n没有提供操作打包产物的接口，没有提供子定义拆包策略的 api</li>\n</ul>\n<h3 id=\"vite-用-esbuild-做了什么\"><a class=\"anchor\" href=\"#vite-用-esbuild-做了什么\">#</a> vite 用 esbuild 做了什么</h3>\n<ul>\n<li>bunder\n<ol>\n<li>在开发环境，为了顺利的实现 <code>no-bunder</code> ，在<strong>预构建</strong>使用 esuild 来将其他的模块化规范转换成了 <code>esm</code> （因为 <code>no-bundler</code>  本质上是利用了浏览器原生支持 esm，让浏览器来请求对应模块）</li>\n<li>使用 esbuild 来对第三方依赖进行打包（避免出现请求瀑布流，浏览器发起过多请求，导致首屏时间过长）</li>\n</ol>\n</li>\n<li>transformer<br />\n 进行单文件编译，作为 TS, JSX, TSX 的编译工具，并且在<strong>生产环境</strong>也是用的 esbuild 来进行编译。但是无法进行 ts 的类型检查，所以还是需要利用 <code>tsc</code>  来进行类型检查</li>\n<li>minifier<br />\n 对 css, js 文件进行压缩</li>\n</ul>\n<h1 id=\"rollup\"><a class=\"anchor\" href=\"#rollup\">#</a> rollup</h1>\n<h3 id=\"vite-用-rollup-做了什么\"><a class=\"anchor\" href=\"#vite-用-rollup-做了什么\">#</a> vite 用 rollup 做了什么</h3>\n<ol>\n<li>\n<p>生产环境利用 <code>rollup</code>  进行打包，并对其进行扩展和优化</p>\n<ul>\n<li>CSS 代码分割<br />\n如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的缓存复用率。</li>\n<li>自动预加载<br />\n Vite 会自动为入口 chunk 的依赖自动生成预加载标签 <code>&lt;link       rel=&quot;modulepreload&quot;&gt;</code></li>\n<li>异步 Chunk 加载优化<br />\n在异步引入的 Chunk 中，通常会有一些公用的模块，如现有两个 异 步引入的 Chunk: A 和 B，而且两者有一个公共依赖 C，一般 情况 下，Rollup 打包之后，会先请求 A，然后浏览器在加载 A 的过程 中才决定请求和加载 C，但 Vite 进行优化之后，请求 A 的同时会 自动预加载 C，通过优化 Rollup 产物依赖加载方式节省 了不必要 的网络开销。</li>\n</ul>\n</li>\n<li>\n<p>兼容了 <code>rollup</code>  的插件机制<br />\n vite 插件可以直接传入 rollup 作为插件使用，但是 rollup 的插件不一定能直接传入 vite 作为 vite 插件使用</p>\n</li>\n</ol>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "深入浅出vite"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/engineeringProblems-viteLearning/",
            "url": "https://zimu-66ccff.github.io/engineeringProblems-viteLearning/",
            "title": "前端工程化痛点-vite的解决方案-深入浅出vite学习",
            "date_published": "2023-07-26T07:04:39.000Z",
            "content_html": "<h1 id=\"前端工程化的痛点及-vite-的解决方案\"><a class=\"anchor\" href=\"#前端工程化的痛点及-vite-的解决方案\">#</a> 前端工程化的痛点及 vite 的解决方案</h1>\n<h3 id=\"痛点一模块化规范太多需要一个支持和兼容\"><a class=\"anchor\" href=\"#痛点一模块化规范太多需要一个支持和兼容\">#</a> 痛点一：模块化规范太多，需要一个支持和兼容</h3>\n<ul>\n<li>vite 的解决方案\n<ul>\n<li>支持 ESM 模块化方案（支持异步，浏览器原生支持），由于浏览器原生支持 ESM，所以可以基于 ESM 实现  <code>no-bunder</code></li>\n<li>兼容其他的模块化方案，通过在 <code>预构建</code> 过程中来使用 <code>esbuild</code>  来将其他模块化方案转换成 ESM</li>\n</ul>\n</li>\n<li>模块化方案面对的问题\n<ul>\n<li>模块的拆分</li>\n<li>模块的依赖关系导致的加载顺序（a 模块依赖 b 模块，那就需要先引入 b 模块再引入 a 模块）</li>\n<li>变量命名冲突</li>\n<li>浏览器是否兼容</li>\n</ul>\n</li>\n<li>模块化方案发展历史\n<ul>\n<li>第一阶段：通过 <code>&lt;script&gt;</code>  来做模块化，但是存在变量命名冲突，模块加载顺序的问题</li>\n<li>第二阶段：通过 <code>命名空间（window.moduleA, window,moduleB）</code> 来做模块化，解决了变量命名冲突，但是 没有解决模块加载顺序的问题</li>\n<li>第三阶段：通过  <code>IIFE（立即执行函数）</code> 来做模块化，解决了变量命名冲突，但是没有解决模块加载顺序的问题</li>\n<li>第四阶段：通过  <code>CommonJS</code>  规范来做模块化，解决了变量冲突，模块加载顺序的问题，但是存在一个加载是同 步的问题（这在浏览器是个大问题，当加载的模块过大时，会阻塞后续代码的执行，会造成界面白屏时间过长），并且 浏览器并不支持这个模块化方案</li>\n<li>第五阶段：通过  <code>AMD</code>  来做模块化，也就是异步模块定义方案，解决了上述的问题，但是写起来太麻烦，并且也 没有得到浏览器的支持</li>\n<li>最终阶段：通过 <code>ESM</code>  来做模块化，完美解决了上述问题所有问题（变量命名冲突，模块加载顺序），并且加载是 异步的，不会阻塞页面渲染，并且是浏览器原生支持</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"痛点二需要对-tstsx-等高级语法做一个转译对静态资源做处理使其能作为一个正常模块加载能够对语法做一个降级并注入一些高级语法以支持低级浏览器\"><a class=\"anchor\" href=\"#痛点二需要对-tstsx-等高级语法做一个转译对静态资源做处理使其能作为一个正常模块加载能够对语法做一个降级并注入一些高级语法以支持低级浏览器\">#</a> 痛点二：需要对 ts，tsx 等高级语法做一个转译，对静态资源做处理，使其能作为一个正常模块加载，能够对语法做一个降级，并注入一些高级语法，以支持低级浏览器</h3>\n<ul>\n<li>vite 的解决方案\n<ul>\n<li>通过 <code>esbuild</code>  来对 ts，tsx 等语法来进行一个转译（但是 ts 的语法检查还是需要 <code>tsc</code> ）</li>\n<li>vite 内置对 JSON 模块的加载（底层使用 @rollup/pluginutils 的 dataToEsm 方法将 JSON 对象转换为一 个包含各种具名导出的 ES 模块）</li>\n<li>通过 <code>bable</code>  来将高级语法编译成低级语法（比如把箭头函数变成普通函数），通过 <code>corejs</code>  来注入一些高级 API (比如 promise)，从而兼容低版本的浏览器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"痛点三提高产物质量要能给对代码进行压缩和-treeshaking\"><a class=\"anchor\" href=\"#痛点三提高产物质量要能给对代码进行压缩和-treeshaking\">#</a> 痛点三：提高产物质量，要能给对代码进行压缩和 Treeshaking</h3>\n<ul>\n<li>vite 的解决方案\n<ul>\n<li>通过 <code>esbuild</code>  来对代码进行一个压缩</li>\n<li>treeShaking (待更新)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"痛点四开发效率低下开发启动时间很长热更新很慢\"><a class=\"anchor\" href=\"#痛点四开发效率低下开发启动时间很长热更新很慢\">#</a> 痛点四：开发效率低下，开发启动时间很长，热更新很慢</h3>\n<ul>\n<li>vite 的解决方案\n<ul>\n<li>开发阶段直接 <code>no-bunder</code>  不打包直接启动，利用浏览器原生支持 ESM 的这一点，让浏览器来加载源代码对应的模块（在预构建过程中，利用 <code>esbuild</code>  来将其他模块化方案转换成 ESM，并打包第三方依赖，避免请求瀑布的出现，导致白屏时间过长）</li>\n<li>热更新（待更新）</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "深入浅出vite"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/download/",
            "url": "https://zimu-66ccff.github.io/download/",
            "title": "前端实现文件下载的几种方式",
            "date_published": "2023-07-18T02:13:12.000Z",
            "content_html": "<h1 id=\"后端提供的下载文件的方式\"><a class=\"anchor\" href=\"#后端提供的下载文件的方式\">#</a> 后端提供的下载文件的方式</h1>\n<ol>\n<li>直接返回文件的网络地址（一般用在静态文件上，比如图片以及各种音视频资源等）</li>\n<li>返回文件流（一般用在动态文件上，比如根据前端选择，导出不同的统计结果 excel 等）</li>\n</ol>\n<h1 id=\"不同方式前端的处理方案\"><a class=\"anchor\" href=\"#不同方式前端的处理方案\">#</a> 不同方式，前端的处理方案</h1>\n<h4 id=\"第一种\"><a class=\"anchor\" href=\"#第一种\">#</a> 第一种</h4>\n<ul>\n<li>\n<p>通过 a 标签的 <code>download</code>  属性和 <code>click</code>  函数</p>\n<figure class=\"highlight html\"><figcaption data-lang=\"HTML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://www.baidu.top.pdf<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">download</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>附件.pdf<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>下载文件<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure></li>\n<li>\n<p><code>window.location.href</code>  (推荐)</p>\n<pre><code class=\"language-javaScript\">&lt;script&gt;\nfunction Download() &#123;\n  window.location.href = 'www.baidu.pdf'\n&#125;\n&lt;/script&gt;\n</code></pre>\n</li>\n<li>\n<p><code>window.open</code>  (推荐)</p>\n<pre><code class=\"language-javaScript\">&lt;script&gt;\n  function Download() &#123;\n    window.open('www.baidu.pdf')\n  &#125;\n&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"第二种-使用-blob-文件流下载\"><a class=\"anchor\" href=\"#第二种-使用-blob-文件流下载\">#</a> 第二种 使用 blob 文件流下载</h4>\n<pre><code class=\"language-javaScript\"> &lt;script&gt;\n    function Download() &#123;\n      axios(&#123;\n        url: &quot;www.baidu.pdf&quot;,\n        method: 'GET',\n        responseType: 'blob', // 这里就是转化为blob文件流\n        headers: &#123;\n          token: 'sss'     // 可以携带token\n        &#125;\n      &#125;).then(res =&gt; &#123;\n        const href = URL.createObjectURL(res.data)\n        const box = document.createElement('a')\n        box.download = '附件.pdf'\n        box.href = href\n        box.click()\n      &#125;)\n    &#125;\n  &lt;/script&gt;\n</code></pre>\n",
            "tags": [
                "笔记",
                "项目",
                "项目",
                "文件下载"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/omi/",
            "url": "https://zimu-66ccff.github.io/omi/",
            "title": "腾讯犀牛鸟开源活动-OMI开源申请书",
            "date_published": "2023-07-17T01:40:03.000Z",
            "content_html": "<h1 id=\"omi-开源申请书\"><a class=\"anchor\" href=\"#omi-开源申请书\">#</a> OMI 开源申请书</h1>\n<h2 id=\"技术方案\"><a class=\"anchor\" href=\"#技术方案\">#</a> 技术方案</h2>\n<h4 id=\"omi-编程任务分解\"><a class=\"anchor\" href=\"#omi-编程任务分解\">#</a> OMI 编程任务分解</h4>\n<ol>\n<li>开发脚手架搭建</li>\n<li>组件开发</li>\n<li>组件设计器开发</li>\n</ol>\n<h4 id=\"任务-1开发-omi-组件库脚手架以自动生成-omi-组件模板辅助后续组件开发并集成-tdesign-common-提供的-tdesign-样式文件和工具函数保持组件的样式风格一致\"><a class=\"anchor\" href=\"#任务-1开发-omi-组件库脚手架以自动生成-omi-组件模板辅助后续组件开发并集成-tdesign-common-提供的-tdesign-样式文件和工具函数保持组件的样式风格一致\">#</a> 任务 1：开发 OMI 组件库脚手架，以自动生成 OMI 组件模板辅助后续组件开发，并集成 Tdesign-common 提供的 Tdesign 样式文件和工具函数，保持组件的样式风格一致</h4>\n<p>实战周期 2--3 周</p>\n<p>目标一：借鉴生态成熟的组件库脚手架 比如 valet-cli 抽离出 OMI 的 webComponents 的公共模板 以自动生成组件模板辅助开发<br />\n预计耗时： 一周</p>\n<p>目标二：在脚手架里集成 Tdesign-common 提供的样式文件和工具函数，以实现通过命令生成对应组件模板的时候可以根据配置选择是否自动导入类似组件的样式文件<br />\n预计耗时：一周</p>\n<p>本人优势：</p>\n<ol>\n<li>研究过 varlet-cli 源码，有脚手架开发经验</li>\n<li>开发过简易脚手架，来自动化实现相关配置和集成<br />\n链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ppTXUtNjZjY2ZmL3ppTXUtY2xp\">https://github.com/ziMu-66ccff/ziMu-cli</span></li>\n<li>可以熟练使用 inquirer，figlet，fs-extra，chalk， commander 等工具库</li>\n<li>有比较好的审美</li>\n</ol>\n<h4 id=\"任务-2利用上一步提供的脚手架来辅助开发基于-omi-和-tdesign-common-的相关组件\"><a class=\"anchor\" href=\"#任务-2利用上一步提供的脚手架来辅助开发基于-omi-和-tdesign-common-的相关组件\">#</a> 任务 2：利用上一步提供的脚手架来辅助开发基于 OMI 和 Tdesign-common 的相关组件</h4>\n<p>实战周期：2-3 周</p>\n<p>目标一：通过对组件的复杂程度排个序，来从简到难的逐步开发相关的组件，可以借鉴主流的生态完善的组件库 比如 ant-design<br />\n 预计耗时 2.5 周</p>\n<p>本人优势:</p>\n<ol>\n<li>在合合信息实习时 参与过部门的高度定制化的组件库的开发，有一定的组件库开发能力</li>\n<li>参加字节青训营时，和小伙伴们一起开发过 lucky-Componets 组件库<br />\n链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0xpdVNlbjY4OC9sdWNreUNvbXBvbmVudHM=\">https://github.com/LiuSen688/luckyComponents</span></li>\n</ol>\n<h4 id=\"任务-3开发基于-omi-的组件设计器\"><a class=\"anchor\" href=\"#任务-3开发基于-omi-的组件设计器\">#</a> 任务 3：开发基于 OMI 的组件设计器</h4>\n<p>实战周期： 3 周以上</p>\n<p>目标：在相关导师的指导下，完善自己低代码开发的能力，努力再努力，热情再热情的完成这个组件设计器的开发</p>\n<h4 id=\"申请人项目经历\"><a class=\"anchor\" href=\"#申请人项目经历\">#</a> 申请人项目经历</h4>\n<p>github：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ppTXUtNjZjY2Zm\">https://github.com/ziMu-66ccff</span></p>\n<ol>\n<li>ziMu-cli， 一款简单的开箱即用的搭建 vue，react 项目的脚手架<br />\n项目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ppTXUtNjZjY2ZmL3ppTXUtY2xp\">https://github.com/ziMu-66ccff/ziMu-cli</span></li>\n<li>lucky-components， 一款合作完成的适配 vue3 的组件库<br />\n项目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0xpdVNlbjY4OC9sdWNreUNvbXBvbmVudHM=\">https://github.com/LiuSen688/luckyComponents</span></li>\n<li>mini-vue3 自己学习 vue3 源码后 写的一个简单的 vue3 框架<br />\n项目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ppTXUtNjZjY2ZmL21pbmktdnVlMw==\">https://github.com/ziMu-66ccff/mini-vue3</span></li>\n<li>前端全栈开发能力 熟练使用 Vue.js， OMI， Nest.js, mongoDB 等</li>\n<li>对 vite，webpack 有一定了解</li>\n<li>目前大二，在合合信息实习</li>\n</ol>\n<p>姓名：李文豪</p>\n",
            "tags": [
                "开源",
                "开源",
                "omi"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/bigProject/",
            "url": "https://zimu-66ccff.github.io/bigProject/",
            "title": "瑞翼工坊暑期大项目宣讲会",
            "date_published": "2023-07-07T07:53:00.000Z",
            "content_html": "<h1 id=\"为什么我们需要做这样的一个平台\"><a class=\"anchor\" href=\"#为什么我们需要做这样的一个平台\">#</a> 为什么我们需要做这样的一个平台？</h1>\n<ol>\n<li>工坊的很多东西 散落在各个地方 刚进来的人无法知道工坊的财富 无法得到自己需要的东西 所以我们用这样的一个平台对其做一个整合，让工坊成员都能得到自己想要的东西</li>\n<li>开发部门的新人缺少一个项目开发的经验，我们以这样的一个平台，来让新人得到锻炼，并且提供一对一的指导</li>\n<li>有新的技术，奇妙的想法，无法付诸于实践， 所以我们提供这样的一个可扩展的平台，随时对其进行扩展。</li>\n<li>开发部门的新人们简历上缺乏一个优秀的，高技术的，真正的项目（有访问量的），缺乏项目部署的经验，业务思维，而我们提供这样的一个项目</li>\n</ol>\n<h1 id=\"开发完毕后我们将得到什么\"><a class=\"anchor\" href=\"#开发完毕后我们将得到什么\">#</a> 开发完毕后，我们将得到什么</h1>\n<ol>\n<li>一个真正的项目开发经验，部署经验（这是区别于网上的项目的）</li>\n<li>获得业务思维，提升业务能力 （业务能力也是面试时很看重的一点，而这种真正的项目，不是为了做而做的项目，有背景的项目可以很好的提升业务思维）</li>\n<li>获取一定的名誉，如果可以的话，项目将向全计信推广，我们也会将开发者的名字放到项目里</li>\n</ol>\n<h1 id=\"具体开发信息\"><a class=\"anchor\" href=\"#具体开发信息\">#</a> 具体开发信息</h1>\n<h3 id=\"模块拆分\"><a class=\"anchor\" href=\"#模块拆分\">#</a> 模块拆分</h3>\n<ul>\n<li>工坊（顶部导航栏）\n<ul>\n<li>瑞翼荣耀 （小卡片）</li>\n<li>场地助手 （小卡片）</li>\n</ul>\n</li>\n<li>技术学习（顶部导航栏）\n<ul>\n<li>方向介绍 （小卡片）\n<ul>\n<li>前端 （小卡片 or 左侧导航栏）</li>\n<li>服务端 （小卡片 or 左侧导航栏）</li>\n<li>vr （小卡片 or 左侧导航栏）</li>\n<li>算法部 （小卡片 or 左侧导航栏）</li>\n</ul>\n</li>\n<li>学习路线 （小卡片）\n<ul>\n<li>前端 （小卡片 or 左侧导航栏）</li>\n<li>服务端 （小卡片 or 左侧导航栏）</li>\n<li>vr （小卡片 or 左侧导航栏）</li>\n<li>算法部 （小卡片 or 左侧导航栏）</li>\n</ul>\n</li>\n<li>每日一问 （小卡片）\n<ul>\n<li>前端 （小卡片 or 左侧导航栏）</li>\n<li>服务端 （小卡片 or 左侧导航栏）</li>\n<li>vr （小卡片 or 左侧导航栏）</li>\n<li>算法部 （小卡片 or 左侧导航栏）</li>\n</ul>\n</li>\n<li>暑期实习，秋招公司信息 （小卡片）</li>\n<li>开发平台 （小卡片）\n<ul>\n<li>jekins （小卡片 or 左侧导航栏）</li>\n<li>coding （小卡片 or 左侧导航栏）</li>\n<li>tapd （小卡片 or 左侧导航栏）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>活动（顶部导航栏）\n<ul>\n<li>训练营 （小卡片） ps：建议支持一键组队功能</li>\n<li>开源活动 （小卡片） ps：建议支持一键组队功能</li>\n<li>比赛 （小卡片） ps: 建议支持一键组队功能</li>\n</ul>\n</li>\n<li>练习（顶部导航栏）\n<ul>\n<li>工坊 oj 平台 （小卡片）</li>\n<li>leetcode （小卡片）</li>\n<li>前端刷题网站 （小卡片）</li>\n</ul>\n</li>\n<li>学校 （顶部导航栏）\n<ul>\n<li>学校平台 （小卡片）\n<ul>\n<li>湖大 vpn （小卡片）</li>\n<li>智慧服务中心 （小卡片）</li>\n<li>教务系统 （小卡片）</li>\n<li>实践系统 （小卡片）</li>\n<li>图书管理系统 （小卡片）</li>\n<li>体测系统 （小卡片）</li>\n<li>LMS 课程平台 （小卡片）</li>\n<li>宿管系统 （小卡片）</li>\n</ul>\n</li>\n<li>课程资料 （小卡片）\n<ul>\n<li>cpp （小卡片 or 左侧一级导航栏） ps： 只是一个例子\n<ul>\n<li>知识总结 （小卡片 or 左侧二级导航栏）</li>\n<li>推荐书籍 （小卡片 or 左侧二级导航栏）</li>\n<li>课后习题答案 （小卡片 or 左侧二级导航栏）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>友链 （顶部导航栏）</li>\n<li>小工具 （顶部导航栏）</li>\n</ul>\n",
            "tags": [
                "学校",
                "学校",
                "瑞翼工坊"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/workflowConfig/",
            "url": "https://zimu-66ccff.github.io/workflowConfig/",
            "title": "前端工作流配置——代码不仅是给机器看的，也是给人看的（持续更新中）",
            "date_published": "2023-06-19T11:41:24.000Z",
            "content_html": "<h1 id=\"eslint\"><a class=\"anchor\" href=\"#eslint\">#</a> eslint</h1>\n<h3 id=\"为什么需要-eslint\"><a class=\"anchor\" href=\"#为什么需要-eslint\">#</a> 为什么需要 eslint</h3>\n<p>因为我们写的代码有时候可能质量并不高，所以我们需要这样的一个工具来 <code>规范我们的代码</code> ，保障我们的 <code>代码质量</code> （比如我们写了一个变量 但是这个变量我们没有使用 那么这个变量就是多余的 这时候我们的 eslint 可以直接报错 让我们知道这个多余的变量应该删除）</p>\n<h3 id=\"怎么在项目中集成-eslint\"><a class=\"anchor\" href=\"#怎么在项目中集成-eslint\">#</a> 怎么在项目中集成 eslint</h3>\n<ol>\n<li>下载 eslint<br />\n 使用你的包管理工具（pnpm，yarn，npm，npx）安装 eslint 具体命令  <code>pnpm install eslint</code></li>\n<li>初始化 eslint（）<br />\n具体命令  <code>pnpm eslint --init</code> , 执行该命令后会让你 <code>回答相关问题</code> ，从而选择适合你的规则来约束你的代码，目的只有一个提高你的代码质量\n<ul>\n<li>how would you like to use eslint?（你想使用 eslint 来做什么）\n<ul>\n<li>to check syntax only（只检查语法）</li>\n<li>to check syntax and find problems（检查语法并找出错误）</li>\n<li>to check syntax, find problems, and enforce code style （检查语法，找出错误，规范代码）</li>\n</ul>\n</li>\n<li>what type of modules does your project use? （你想使用什么模块化规范）\n<ul>\n<li>javascript modules (import/export)</li>\n<li>commonjs (require/exports)</li>\n<li>none of these</li>\n</ul>\n</li>\n<li>which framework does your project use? （你想使用什么框架）\n<ul>\n<li>React</li>\n<li>Vue</li>\n<li>none of these</li>\n</ul>\n</li>\n<li>Does your project use Typescript No/Yes （是否要使用 ts）</li>\n<li>Where does your code run? （代码运行在什么环境，一般两个都选）\n<ul>\n<li>Browser</li>\n<li>Node</li>\n</ul>\n</li>\n<li>How would you like to define a style for your project? （你想怎么来定义 eslint 的规则， 推荐直接使用流行的规范）\n<ul>\n<li>use a popular style guide （使用流行的规范）</li>\n<li>answer questions about your style （通过询问问题 得到你想要的规范吧）</li>\n<li>inspect your javascript files （根据配置文件 生成规范）</li>\n</ul>\n</li>\n<li>Which style guide do you want to to follow? （你想使用哪个流行的规范）\n<ul>\n<li>Standard</li>\n<li>XO</li>\n</ul>\n</li>\n<li>What format do you want your config file to be in ? （配置文件的格式 建议直接选择 JavaScript）\n<ul>\n<li>javascript</li>\n<li>yaml</li>\n<li>json</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>vscode 安装 eslint 插件</li>\n</ol>\n<h3 id=\"eslintcjs-配置文件的相关配置项解析\"><a class=\"anchor\" href=\"#eslintcjs-配置文件的相关配置项解析\">#</a> .eslint.cjs 配置文件的相关配置项解析</h3>\n<ol>\n<li>\n<p>parser - 解析器<br />\n ESLint 底层默认使用 Espree 来进行 AST 解析，这个解析器目前已经基于 Acron 来实现，虽然说 Acron 目前能够解析绝大多数的 ECMAScript 规范的语法，但还是不支持 TypeScript ，因此需要引入其他的解析器完成 TS 的解析。</p>\n<p>社区提供了 @typescript-eslint/parser 这个解决方案，专门为了 TypeScript 的解析而诞生，将 TS 代码转换为 Espree 能够识别的格式 (即 Estree 格式)，然后在 Eslint 下通过 Espree 进行格式检查， 以此兼容了 TypeScript 语法。</p>\n</li>\n<li>\n<p>parserOptions - 解析器选项<br />\n这个配置可以对上述的解析器进行能力定制，默认情况下 ESLint 支持 ES5 语法，你可以配置这个选项，具体内容如下:</p>\n<p>ecmaVersion: 这个配置和 Acron 的 ecmaVersion 是兼容的，可以配置 ES + 数字 (如 ES6) 或者 ES + 年份 (如 ES2015)，也可以直接配置为 latest，启用最新的 ES 语法。<br />\nsourceType: 默认为 script，如果使用 ES Module 则应设置为 module<br />\necmaFeatures: 为一个对象，表示想使用的额外语言特性，如开启 jsx。</p>\n</li>\n<li>\n<p>rules - 具体代码规则<br />\n rules 配置即代表在 ESLint 中手动调整哪些代码规则，比如禁止在 if 语句中使用赋值语句这条规则可以像如下的方式配置:</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// .eslintrc.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">// 其它配置省略</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">//key 为规则名，value 配置内容</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token string-property property\">'no-cond-assign'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'always'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在 rules 对象中，key 一般为规则名，value 为具体的配置内容，在上述的例子中我们设置为一个数组，数组第一项为规则的 ID，第二项为规则的配置。</p>\n<p>这里重点说一说规则的 ID，它的语法对所有规则都适用，你可以设置以下的值:</p>\n<p>off 或 0: 表示关闭规则。</p>\n<p>warn 或 1: 表示开启规则，不过违背规则后只抛出 warning，而不会导致程序退出。<br />\nerror 或 2: 表示开启规则，不过违背规则后抛出 error，程序会退出。<br />\n具体的规则配置可能会不一样，有的是一个字符串，有的可以配置一个对象，你可以参考 ESLint 官方文档。</p>\n<p>当然，你也能直接将 rules 对象的 value 配置成 ID，如: &quot;no-cond-assign&quot;: &quot;error&quot;。</p>\n</li>\n<li>\n<p>plugins<br />\n 上面提到过 ESLint 的 parser 基于 Acorn 实现，不能直接解析 TypeScript，需要我们指定 parser 选项为 @typescript-eslint/parser 才能兼容 TS 的解析。同理，ESLint 本身也没有内置 TypeScript 的代码规则，这个时候 ESLint 的插件系统就派上用场了。我们需要通过添加 ESLint 插件来增加一些特定的规则，比如添加 @typescript-eslint/eslint-plugin 来拓展一些关于 TS 代码的规则，如下代码所示:</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// .eslintrc.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">// 添加 TS 规则，可省略 `eslint-plugin`</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'@typescript-eslint'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>值得注意的是，添加插件后只是拓展了 ESLint 本身的规则集，但 ESLint 默认并没有 开启这些规则的校验！如果要开启或者调整这些规则，你需要在 rules 中进行配置，如:</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// .eslintrc.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">// 开启一些 TS 规则</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token string-property property\">'@typescript-eslint/ban-ts-comment'</span><span class=\"token operator\">:</span> <span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token string-property property\">'@typescript-eslint/no-explicit-any'</span><span class=\"token operator\">:</span> <span class=\"token string\">'warn'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>extends - 继承配置<br />\n extends 相当于继承另外一份 ESLint 配置，可以配置为一个字符串，也可以配置成一个 字符串数组。主要分如下 3 种情况:</p>\n<p>从 ESLint 本身继承；<br />\n从类似 eslint-config-xxx 的 npm 包继承；<br />\n从 ESLint 插件继承。</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// .eslintrc.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token string-property property\">\"extends\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 第 1 种情况</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token string\">\"eslint:recommended\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 第 2 种情况，一般配置的时候可以省略 `eslint-config`</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token string\">\"standard\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 第 3 种情况，可以省略包名中的 `eslint-plugin`</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 格式一般为: `plugin:$&#123;pluginName&#125;/$&#123;configName&#125;`</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token string\">\"plugin:react/recommended\"</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token string\">\"plugin:@typescript-eslint/recommended\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>有了 extends 的配置，对于之前所说的 ESLint 插件中的繁多配置，我们就不需要手动 一一开启了，通过 extends 字段即可自动开启插件中的推荐规则:</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">extends</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"plugin:@typescript-eslint/recommended\"</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure></li>\n<li>\n<p>env 和 globals<br />\n 这两个配置分别表示运行环境和全局变量，在指定的运行环境中会预设一些全局变量，比如:</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// .eslint.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>module<span class=\"token punctuation\">.</span>export <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token literal-property property\">env</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token literal-property property\">browser</span><span class=\"token operator\">:</span> <span class=\"token string\">'true'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token literal-property property\">node</span><span class=\"token operator\">:</span> <span class=\"token string\">'true'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>指定上述的 env 配置后便会启用浏览器和 Node.js 环境，这两个环境中的一些全局变量 (如 window、global 等) 会同时启用。</p>\n<p>有些全局变量是业务代码引入的第三方库所声明，这里就需要在 globals 配置中声明全局变 量了。每个全局变量的配置值有 3 种情况:</p>\n<p>&quot;writable&quot; 或者 true，表示变量可重写；<br />\n&quot;readonly&quot; 或者 false，表示变量不可重写；<br />\n&quot;off&quot;，表示禁用该全局变量。</p>\n</li>\n</ol>\n<h1 id=\"prettier\"><a class=\"anchor\" href=\"#prettier\">#</a> prettier</h1>\n<h3 id=\"为啥需要-prettier\"><a class=\"anchor\" href=\"#为啥需要-prettier\">#</a> 为啥需要 prettier</h3>\n<p>因为我们写的代码有时候需要可以的控制格式 比如：换行 缩进之类的 当代码量多起来 这就显得非常麻烦 所以我们需要一个工具 来自动帮我们格式化代码（让代码格式变正确）</p>\n<h3 id=\"怎么在项目中集成-prettier\"><a class=\"anchor\" href=\"#怎么在项目中集成-prettier\">#</a> 怎么在项目中集成 prettier</h3>\n<ol>\n<li>\n<p>下载 prettier 命令：  <code>pnpm install prettier</code></p>\n</li>\n<li>\n<p>和 eslint 适配</p>\n<ul>\n<li>下载 eslint-config-prettier (用于用 prettier 的规则来覆盖部分 eslint 的规则) eslint-plugin-prettier（用来让 prettier 来接管 eslint 修复代码的功能）</li>\n<li>在.eslintrc.cjs 文件里面的 <code>extend</code>  属性里面添加 <code>&quot;prettier&quot;</code>  来解决 eslint 和 prettier 的冲突，让 prerrier 适配 eslint</li>\n</ul>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// .eslintrc.cjs</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>module<span class=\"token punctuation\">.</span>export <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">extends</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'prettier'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>添加.prettierrc 文件来配置 prettier 相关规则</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// .prettierrc.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token literal-property property\">printWidth</span><span class=\"token operator\">:</span> <span class=\"token number\">80</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 一行的字符数，如果超过会进行换行，默认为 80</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token literal-property property\">tabWidth</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 一个 tab 代表几个空格数，默认为 2 个</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token literal-property property\">useTabs</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 是否使用 tab 进行缩进，默认为 false，表示用空格进行缩减</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token literal-property property\">singleQuote</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 字符串是否使用单引号，默认为 false，使用双引号</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token literal-property property\">semi</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 行尾是否使用分号，默认为 true</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token literal-property property\">trailingComma</span><span class=\"token operator\">:</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 是否使用尾逗号</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token literal-property property\">bracketSpacing</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 对象大括号直接是否有空格，默认为 true，效果：&#123;a: 1&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>vscode 下载 prettier 插件<br />\n vscode 下载了 prettier 插件后 在 vscode 的设置里面将 Format on Save 开启。这样当你 ctrl + s 保存的时候代码就会自动被 prettier 格式化<br />\n<img data-src=\"https://i.imgloc.com/2023/06/19/Vj92oU.png\" alt=\"Vj92oU.png\" /></p>\n</li>\n</ol>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "工作流配置"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/firstInternship/",
            "url": "https://zimu-66ccff.github.io/firstInternship/",
            "title": "埋种一年半，终破土而出",
            "date_published": "2023-06-09T10:37:32.000Z",
            "content_html": "<h1 id=\"故事开始埋下种子\"><a class=\"anchor\" href=\"#故事开始埋下种子\">#</a> 故事开始，埋下种子</h1>\n<p>我想，如果我没有记错的话，我应该是 2022 年的 2 月份埋下了这颗种子，在一个敲可爱的学长（ <code>舒总</code> ，敲击强的字节跳动大佬）的带动下开始邂逅前端开发，那时不知道前方是什么，只是觉得很新鲜，很酷，并未想到它会给我带来这么多美好的东西（与很多有趣，努力，温柔的人相遇；为我带来未来就业的极大便利）<br />\n<img data-src=\"https://i.imgloc.com/2023/06/09/V2pvEF.jpeg\" alt=\"V2pvEF.jpeg\" /></p>\n<h1 id=\"加入瑞翼工坊学校的一个工作室\"><a class=\"anchor\" href=\"#加入瑞翼工坊学校的一个工作室\">#</a> 加入瑞翼工坊（学校的一个工作室）</h1>\n<p>后来，加入了学校的工作室，目的其实也很简单，只是想遇见一些同行的人，有一个学习技术，追求技术的空间；实际上，我后来的时间也基本上全是在这里。早上睡醒了就去，晚上夜深而归，会有很多一同学习技术的人在这里学习到很晚，真的是一个很好的环境和氛围。<br />\n认识了很多有趣的人， <code>舒总</code> ， <code>小双哥</code> ， <code>陈老师</code> ， <code>林学长</code> ， <code>匡学姐</code> ， <code>李佬</code> ， <code>王佬</code> ， <code>叶桑</code> ， <code>博神</code> 等...，<strong>人与人的相遇总是美好的</strong>。<br />\n也遇到了很多大一的后辈们，都很努力，很认真， <code>梦玉</code> ， <code>于瑛</code> ， <code>杨冉</code> ， <code>蔡典</code> ， <code>孙子龙</code> <br />\n<img data-src=\"https://i.imgloc.com/2023/06/09/V2pSu8.jpeg\" alt=\"V2pSu8.jpeg\" /><br />\n<img data-src=\"https://i.imgloc.com/2023/06/09/V2psHZ.jpeg\" alt=\"V2psHZ.jpeg\" /></p>\n<h1 id=\"新年小愿望的许下\"><a class=\"anchor\" href=\"#新年小愿望的许下\">#</a> 新年小愿望的许下</h1>\n<p>在 2023 年来临的时候，许下了一些小愿望，希望可以找到实习，可以和更多温柔的人相遇，身边的两三个很重要的人依旧在我身边</p>\n<p><img data-src=\"https://i.imgloc.com/2023/06/09/V2p5d5.jpeg\" alt=\"V2p5d5.jpeg\" /></p>\n<h1 id=\"找实习的痛苦温柔的人的帮助和鼓励第一段实习真的太难找了\"><a class=\"anchor\" href=\"#找实习的痛苦温柔的人的帮助和鼓励第一段实习真的太难找了\">#</a> 找实习的痛苦，温柔的人的帮助和鼓励（第一段实习真的太难找了）</h1>\n<ul>\n<li>寒气逼人<br />\n现在行情确实很不好，真的是寒气逼人，找第一段实习真的是很困难，学校是双非，学历并没有有事，第一次找实习，当然也没有实习经历，真的就是全考运气。记得在 boss 直聘上面沟通了八九十次，简历却只投出去了了了几份，甚至没人约面。那段时间真的是很绝望，对自己的打击也确实很大，那时经常会到实训大楼的顶层吹风，以图忘记一切烦恼。</li>\n<li>帮助与鼓励<br />\n好在遇到了很多温柔的人， <code>咖啡哥</code> 耐心的给我做模拟面试，给我鼓劲，让我再耐心的沉淀沉淀。 <code>嘉晨</code> ， <code>沈七哥</code> ，我们互相鼓励，一同前行，最终结果也都很好。我在 <code>小双哥</code> 的内推下，顺利进入<em>合合信息</em>；嘉晨则是进入<em>绿盟</em>；沈七哥也顺利进入<em>第四范式</em>，<strong>一个人只能走很短的路，而一群人可以走的很远</strong><br />\n<a href=\"https://imgloc.com/i/V2phNy\"><img data-src=\"https://i.imgloc.com/2023/06/09/V2phNy.jpeg\" alt=\"V2phNy.jpeg\" /></a></li>\n</ul>\n<h1 id=\"终破土而出顺利开启实习生活\"><a class=\"anchor\" href=\"#终破土而出顺利开启实习生活\">#</a> 终破土而出（顺利开启实习生活）</h1>\n<p>后来终于拿到了合合信息的前端实习生岗位的 offer，在这里体验到了真正的企业开发，事情不是很多，但是上线那会真的把我忙炸了，需求疯狂调整，一天发布好几次。不过整体真的是个很好的经历<br />\n也遇见了很多有趣的人，部门 boss <code>徐杰哥</code> （请我们部门全员吃了贼好吃的冰激凌，笑死了，进来一个月我不认识部门 boss） leader <code>佳骏哥</code> （人超级好，全能，超级厉害，啥都会），mentor  <code>seven哥</code> （前端架构师，超级厉害）带教 mentor <code>慧东哥</code> （超级温柔，耐心，经常请我们喝咖啡），组长 <code>付同哥</code> （后端架构师，经常和我们开玩笑，聊天），后端老哥  <code>建辉哥</code> （很耐心，对我们很宽容）， 后端老哥  <code>永辉哥</code> （凶凶的，又很搞笑），产品经理  <code>崔老师</code> （人很好，会让我们慢慢做需求，虽然上线那几天需求变动频繁给我搞麻了）等...<br />\n 当然还有另外一个实习生姐姐， <code>兰英姐</code> （嘤嘤嘤），部门就我们两个前端实习生，算是相依为命了，也确实是相依为命。姐姐超级可爱，温柔，好看，很大程度上提升了我的实习体验，我们一起摸鱼，一起干饭，一起吐槽。真的是个很温柔的姐姐，能遇到这样温柔的人，真的是很开心的一件事情。（附上一张姐姐的美照，已取的当事人同意）<br />\n<a href=\"https://imgloc.com/i/V2pd43\"><img data-src=\"https://i.imgloc.com/2023/06/09/V2pd43.png\" alt=\"V2pd43.png\" /></a><br />\n<a href=\"https://imgloc.com/i/V2pXqa\"><img data-src=\"https://i.imgloc.com/2023/06/09/V2pXqa.jpeg\" alt=\"V2pXqa.jpeg\" /></a></p>\n<h1 id=\"和很多美好的人相遇\"><a class=\"anchor\" href=\"#和很多美好的人相遇\">#</a> 和很多美好的人相遇</h1>\n<p>一路上真的遇见了很多美好的人，也到到了很多他们的帮助， <code>🐏哥</code> ， <code>舒佬</code> ， <code>咖啡哥</code> ，  <code>兰英姐</code> ， <code>嘉晨</code> ，  <code>沈七哥</code> ，  <code>阳树哥</code> ，  <code>研二哥</code> ， <code>大专哥</code> ， <code>小双哥</code> ，  <code>陈老师</code> ，  <code>林学长</code> ， <code>匡姐</code> ， <code>李佬</code> <br />\n（附上第一次上海会师，🐏 哥超级帅）<br />\n<img data-src=\"https://i.imgloc.com/2023/06/09/V2ppIz.jpeg\" alt=\"V2ppIz.jpeg\" /></p>\n",
            "tags": [
                "随笔",
                "自我"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/frontEndModularity/",
            "url": "https://zimu-66ccff.github.io/frontEndModularity/",
            "title": "前端模块化分析与对比",
            "date_published": "2023-04-18T05:50:07.000Z",
            "content_html": "<h1 id=\"commonjs\"><a class=\"anchor\" href=\"#commonjs\">#</a> CommonJS</h1>\n<h2 id=\"核心函数\"><a class=\"anchor\" href=\"#核心函数\">#</a> 核心函数</h2>\n<ul>\n<li>exports<br />\n <code>exports</code>  是一个 object，可以在它身上添加需要导出的属性，是默认的根本导出的对象</li>\n<li>module.exports<br />\n <code>module.exports</code>  是被模块直接导出的对象，它实际上默认是 <code>exports</code>  的引用</li>\n<li>require<br />\n <code>require</code>  实际上是会执行要导出的模块里的 code，然后导入被导入模块的 <code>module.exports</code></li>\n</ul>\n<h2 id=\"加载模式\"><a class=\"anchor\" href=\"#加载模式\">#</a> 加载模式</h2>\n<p>commonJS 的加载模式是<strong>运行时</strong>的，<strong>同步</strong>的，它是当代码运行到 <code>require</code>  函数的这一行时，才会开始加载模块，并且执行模块里面的代码，模块里的代码执行完毕才会执行下一行。</p>\n<h2 id=\"加载模式带来的特点\"><a class=\"anchor\" href=\"#加载模式带来的特点\">#</a> 加载模式带来的特点</h2>\n<ul>\n<li>基于这个运行时的机制，require 才可以在<strong>任何地方</strong>使用，并且在路径里面可以<strong>使用变量</strong>，因为此时变量已经有了值</li>\n<li>基于这个同步的机制，当 require 的模块还在加载中时，导入的变量的值会是 <code>undefined</code>  (常见于循环引用中，比如 b 依赖于 a， 而 a 又没执行完毕， 那么 <code>require A</code>  的值则会是 <code>undefined</code> )</li>\n</ul>\n<h2 id=\"commonjs对循环依赖的处理\"><a class=\"anchor\" href=\"#commonjs对循环依赖的处理\">#</a> CommonJS 对循环依赖的处理</h2>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// index.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./counter.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>exports<span class=\"token punctuation\">.</span>message <span class=\"token operator\">=</span> <span class=\"token string\">\"hello world!\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// counter.js</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">let</span> message <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./index.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>exports<span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>打印的结果为： 5 undefined</p>\n<p>原因：</p>\n<ul>\n<li>首先加载 <code>index.js</code> ，执行到第一行的时候遇到 require，开始加载 <code>counter.js</code></li>\n<li><code>counter.js</code>  的第一行被执行，又遇到 require，需要去加载 <code>index.js</code> ，但此时 <code>index.js</code>  还没有加载完毕， 所以此时 message 的值为 undefined</li>\n<li>count 变量被导出</li>\n<li>注册定时器宏任务，打印 message（值为 undefined）</li>\n<li>回到 <code>index.js</code></li>\n<li>打印 count（值为 5）</li>\n<li>导出 message（值为 ‘hello world’）， 然而已经没用了，因为 <code>counter.js</code>  里面的 message 的值已经被解析为了 undefined</li>\n<li>执行定时器宏任务，打印 message（值为 undefined）</li>\n</ul>\n<h1 id=\"esmodule\"><a class=\"anchor\" href=\"#esmodule\">#</a> ESModule</h1>\n<h2 id=\"加载模式-2\"><a class=\"anchor\" href=\"#加载模式-2\">#</a> 加载模式</h2>\n<p>ESModule 的加载模式是分为构建阶段，实例化阶段，执行阶段的， 并且所有模块都是<strong>异步递归加载解析的</strong>。而对依赖关系的处理是在构建阶段，也就是<strong>解析时</strong>进行</p>\n<ol>\n<li><strong>构建阶段</strong><br />\n主要是浏览器尝试下载所有需要的模块文件，并形成模块记录的过程</li>\n</ol>\n<ul>\n<li>浏览器开始解析入口模块文件（是解析，不是执行，只是为了确定依赖），确定入口文件的依赖模块，从而发送请求，下载相关依赖模块。等到依赖模块文件返回后，浏览器继续解析这些依赖模块文件，从而确定依赖文件的依赖，然后发请求下载，并解析，如此循环递归，直到所有依赖文件全部被下载。</li>\n<li>每个模块加载完毕后，都会创建相应的<strong>模块记录</strong>，同时浏览器还会维护一张<strong>模块映射表</strong>，它保存了<strong>模块路径 -- 模块记录</strong>的映射关系。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>实例化阶段</strong><br />\n主要是将模块里面的<strong> export 和 import</strong> 和<strong>内存</strong>建立起关系， 也就是为<strong> export</strong> 开辟内存空间。</li>\n</ol>\n<ul>\n<li>实现 JS 引擎慧创建一个模块环境记录，用来管理模块中导入和导出的变量</li>\n<li>首先处理<strong> export</strong>, 为每一个<strong> export</strong> 在内存中开辟一个对应的空间，但是这个时候内存空间里面没有值，赋值操作是在执行阶段发生的。</li>\n<li>JS 引擎处理完模块所有的导出之后，才会开始处理模块的导入，对同一个模块的导入和导出指<strong>向的是内存中的同一片内存空间</strong></li>\n</ul>\n<ol start=\"3\">\n<li><strong>执行阶段</strong></li>\n</ol>\n<ul>\n<li>开始执行 js 代码，进行赋值操作，将变量的值填充到对应的内存空间</li>\n</ul>\n<h2 id=\"加载模式带来的特点-2\"><a class=\"anchor\" href=\"#加载模式带来的特点-2\">#</a> 加载模式带来的特点</h2>\n<ul>\n<li>ESModule 对模块的下载和解析是发生在构建阶段的时候的，这个时候 js 代码还没执行，变量还没值（js 引擎连内存空间都还没给它开辟），所以<strong> import 语句不能携带变量</strong>，<strong>不能直接在代码块中嵌入</strong></li>\n</ul>\n<h1 id=\"esmodule-对循环依赖的处理\"><a class=\"anchor\" href=\"#esmodule-对循环依赖的处理\">#</a> ESModule 对循环依赖的处理</h1>\n<p>下面让我们来看一个循环依赖的例子，并分析和处理。</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// index.js</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">&#123;</span> count <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./counter.js\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> message <span class=\"token operator\">=</span> <span class=\"token string\">\"666\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">export</span> <span class=\"token punctuation\">&#123;</span> message <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// counter.js</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">&#123;</span> message <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./index.js\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">const</span> count <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">export</span> <span class=\"token punctuation\">&#123;</span> count <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>打印的结果为：5 666</p>\n<p>原因：</p>\n<ul>\n<li>构建阶段\n<ul>\n<li>浏览器下载 <code>index.js</code>  文件</li>\n<li>下载完毕后，开始解析 <code>index.js</code>  文件，发现 <code>index.js</code>  依赖 <code>counter.js</code></li>\n<li>下载 <code>counter.js</code></li>\n<li>下载完毕后，解析 <code>counter.js</code>  文件，发现没有依赖</li>\n<li>构建阶段完毕</li>\n</ul>\n</li>\n<li>实例化阶段\n<ul>\n<li>为 <code>index.js</code>  和 <code>counter.js</code>  的 <code>export</code>  在内存中开辟一段内存空间</li>\n<li>将 <code>import</code>  指向其对应的模块的 <code>export</code>  的内存空间</li>\n</ul>\n</li>\n<li>执行阶段\n<ul>\n<li>执行 <code>index.js</code>  中的代码，将局部变量 message 赋值为 666（此时 message 还没有被写入到 export 的那片内存）</li>\n<li>打印导入的 count，但是此时 import 指向的那片内存，count 还没有被填充，所以开始执行 <code>counter.js</code>  的代码。</li>\n<li>将局部变量 count 赋值为 5（此时 count 还没有被写入到 export 的那片内存）</li>\n<li>将定时器宏任务加入消息队列</li>\n<li>执行 <code>export</code>  来将 count 填充到内存空间</li>\n<li>继续执行 <code>index.js</code> ，此时 import 指向的内存空间（就是 counter.js 的 export 的内存空间）count 已经被填充，顺利打印出 5.</li>\n<li>执行 <code>export</code>  来将 message 填充到内存空间</li>\n<li>执行计时器宏任务中的 callback，此时 <code>counter.js</code>  的 <code>import</code>  指向的内存空间（就是 index.js 的 export 的内存空间）message 已经被填充，顺利答应出 666</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "笔记",
                "前端",
                "前端工程化",
                "前端",
                "前端工程化",
                "前端模块化"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/reactHooks/",
            "url": "https://zimu-66ccff.github.io/reactHooks/",
            "title": "ReactHooks的原理解析",
            "date_published": "2023-03-04T04:25:19.000Z",
            "content_html": "<h1 id=\"hooks-使用规则\"><a class=\"anchor\" href=\"#hooks-使用规则\">#</a> hooks 使用规则</h1>\n<ol>\n<li>hooks 只能在函数组件 or 自定义 hook 的顶部使用</li>\n<li>不能在条件，循环，嵌套函数中使用 hooks</li>\n</ol>\n<h1 id=\"为什么会有这样的规则hooks-究竟是怎么保存我们函数组件的状态的\"><a class=\"anchor\" href=\"#为什么会有这样的规则hooks-究竟是怎么保存我们函数组件的状态的\">#</a> 为什么会有这样的规则，hooks 究竟是怎么保存我们函数组件的状态的？</h1>\n<p><strong>Not Magic, Just Arrays</strong></p>\n<h1 id=\"基本原理\"><a class=\"anchor\" href=\"#基本原理\">#</a> 基本原理</h1>\n<ul>\n<li>函数组件初次执行阶段</li>\n</ul>\n<ol>\n<li>React 会维护一个数组 <code>componentHooks</code> ，和一个索引 <code>componentHookIndex</code></li>\n<li>函数组件中的 <code>useState</code>  被调用时，初始值和修改初始值的方法被存进 <code>pair</code>  数组，然后再将 <code>pair</code>  数组通过索引 <code>componentHookIndex</code>  存进 <code>componentHooks</code>  数组，然后 <code>componentHookIndex++</code>  指向下一个空位。</li>\n<li>随着 <code>useState</code>  的顺序调用，一个个保存着初始值和修改初始值方法的 <code>pair</code>  被存进 <code>componentHookIndex</code> 。</li>\n</ol>\n<ul>\n<li>函数组件的更新阶段</li>\n</ul>\n<ol>\n<li>随着修改初始值的方法被调用，函数组件会被重新执行，并且 <code>componentHookIndex</code>  会被重置为 <code>0</code> , 然后因为我们是按照规则使用的 hooks，所以 hooks 的调用是按照固定的顺序的（<strong>这个固定的顺序，就是为什么要遵守 hooks 的使用规则</strong>）， <code>useState</code>  就可以通过 <code>componentHooks</code>  和 <code>componentsHooksIndex</code>  把我们保存的 <code>pair</code>  返回给我们，然后 <code>componentHookIndex++</code>  指向下一个保存的 <code>pair</code> 。以此来完成之前保存的状态和修改状态的方法的返回。</li>\n</ol>\n<h1 id=\"代码实现此代码实现来自官方文档\"><a class=\"anchor\" href=\"#代码实现此代码实现来自官方文档\">#</a> 代码实现（此代码实现来自官方文档）</h1>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">let</span> componentHooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">let</span> currentHookIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// How useState works inside React (simplified).</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">let</span> pair <span class=\"token operator\">=</span> componentHooks<span class=\"token punctuation\">[</span>currentHookIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pair<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// This is not the first render,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// so the state pair already exists.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// Return it and prepare for next Hook call.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    currentHookIndex<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span> pair<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token comment\">// This is the first time we're rendering,</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token comment\">// so create a state pair and store it.</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  pair <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>initialState<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token keyword\">function</span> <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">// When the user requests a state change,</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">// put the new value into the pair.</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    pair<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nextState<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">updateDOM</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>  <span class=\"token comment\">// Store the pair for future renders</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>  <span class=\"token comment\">// and prepare for the next Hook call.</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>  componentHooks<span class=\"token punctuation\">[</span>currentHookIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pair<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>  currentHookIndex<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>  <span class=\"token keyword\">return</span> pair<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">Gallery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>  <span class=\"token comment\">// Each useState() call will get the next pair.</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">,</span> setIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>showMore<span class=\"token punctuation\">,</span> setShowMore<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>  <span class=\"token keyword\">function</span> <span class=\"token function\">handleNextClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token function\">setIndex</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>  <span class=\"token keyword\">function</span> <span class=\"token function\">handleMoreClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token function\">setShowMore</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>showMore<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>  <span class=\"token keyword\">let</span> sculpture <span class=\"token operator\">=</span> sculptureList<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>  <span class=\"token comment\">// This example doesn't use React, so</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>  <span class=\"token comment\">// return an output object instead of JSX.</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token literal-property property\">onNextClick</span><span class=\"token operator\">:</span> handleNextClick<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token literal-property property\">onMoreClick</span><span class=\"token operator\">:</span> handleMoreClick<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    <span class=\"token literal-property property\">header</span><span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$&#123;</span>sculpture<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">&#125;</span></span><span class=\"token string\"> by </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$&#123;</span>sculpture<span class=\"token punctuation\">.</span>artist<span class=\"token interpolation-punctuation punctuation\">&#125;</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token literal-property property\">counter</span><span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$&#123;</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token interpolation-punctuation punctuation\">&#125;</span></span><span class=\"token string\"> of </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$&#123;</span>sculptureList<span class=\"token punctuation\">.</span>length<span class=\"token interpolation-punctuation punctuation\">&#125;</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>    <span class=\"token literal-property property\">more</span><span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$&#123;</span>showMore <span class=\"token operator\">?</span> <span class=\"token string\">'Hide'</span> <span class=\"token operator\">:</span> <span class=\"token string\">'Show'</span><span class=\"token interpolation-punctuation punctuation\">&#125;</span></span><span class=\"token string\"> details</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span> showMore <span class=\"token operator\">?</span> sculpture<span class=\"token punctuation\">.</span>description <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token literal-property property\">imageSrc</span><span class=\"token operator\">:</span> sculpture<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token literal-property property\">imageAlt</span><span class=\"token operator\">:</span> sculpture<span class=\"token punctuation\">.</span>alt<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre></pre></td></tr><tr><td data-num=\"61\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">updateDOM</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>  <span class=\"token comment\">// Reset the current Hook index</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>  <span class=\"token comment\">// before rendering the component.</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>  currentHookIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>  <span class=\"token keyword\">let</span> output <span class=\"token operator\">=</span> <span class=\"token function\">Gallery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>  <span class=\"token comment\">// Update the DOM to match the output.</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>  <span class=\"token comment\">// This is the part React does for you.</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>  nextButton<span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> output<span class=\"token punctuation\">.</span>onNextClick<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>  header<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> output<span class=\"token punctuation\">.</span>header<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>  moreButton<span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> output<span class=\"token punctuation\">.</span>onMoreClick<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>  moreButton<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> output<span class=\"token punctuation\">.</span>more<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>  image<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> output<span class=\"token punctuation\">.</span>imageSrc<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>  image<span class=\"token punctuation\">.</span>alt <span class=\"token operator\">=</span> output<span class=\"token punctuation\">.</span>imageAlt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>output<span class=\"token punctuation\">.</span>description <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>    description<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> output<span class=\"token punctuation\">.</span>description<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>    description<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>    description<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre></pre></td></tr><tr><td data-num=\"83\"></td><td><pre><span class=\"token keyword\">let</span> nextButton <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nextButton'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre><span class=\"token keyword\">let</span> header <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'header'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre><span class=\"token keyword\">let</span> moreButton <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'moreButton'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre><span class=\"token keyword\">let</span> description <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'description'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre><span class=\"token keyword\">let</span> image <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'image'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre><span class=\"token keyword\">let</span> sculptureList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Homenaje a la Neurocirugía'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Marta Colvin Andrade'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>      <span class=\"token string\">'Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/Mx7dA2Y.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'A bronze statue of two crossed hands delicately holding a human brain in their fingertips.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Floralis Genérica'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Eduardo Catalano'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre>      <span class=\"token string\">'This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/ZF6s192m.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Eternal Presence'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'John Woodrow Wilson'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"108\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>      <span class=\"token string\">'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"110\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/aTtVpES.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"111\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"114\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Moai'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Unknown Artist'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"116\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"117\"></td><td><pre>      <span class=\"token string\">'Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"118\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/RCwLEoQm.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"119\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'Three monumental stone busts with the heads that are disproportionately large with somber faces.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"120\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"121\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"122\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Blue Nana'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"123\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Niki de Saint Phalle'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"124\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"125\"></td><td><pre>      <span class=\"token string\">'The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"126\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/Sd1AgUOm.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"127\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"128\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"129\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"130\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Ultimate Form'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"131\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Barbara Hepworth'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"132\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"133\"></td><td><pre>      <span class=\"token string\">'This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"134\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/2heNQDcm.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"135\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'A tall sculpture made of three elements stacked on each other reminding of a human figure.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"136\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"137\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"138\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Cavaliere'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"139\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Lamidi Olonade Fakeye'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"140\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"141\"></td><td><pre>      <span class=\"token string\">\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"142\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/wIdGuZwm.png'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"143\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"144\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"145\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"146\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Big Bellies'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"147\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Alina Szapocznikow'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"148\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"149\"></td><td><pre>      <span class=\"token string\">'Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"150\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/AlHTAdDm.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"151\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"152\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"153\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"154\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Terracotta Army'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"155\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Unknown Artist'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"156\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"157\"></td><td><pre>      <span class=\"token string\">'The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"158\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/HMFmH6m.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"159\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"160\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"161\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"162\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Lunar Landscape'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"163\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Louise Nevelson'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"164\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"165\"></td><td><pre>      <span class=\"token string\">'Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism’s geometric abstraction of space and form.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"166\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/rN7hY6om.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"167\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'A black matte sculpture where the individual elements are initially indistinguishable.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"168\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"169\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"170\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Aureole'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"171\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Ranjani Shettar'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"172\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"173\"></td><td><pre>      <span class=\"token string\">'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"174\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/okTpbHhm.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"175\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"176\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"177\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"178\"></td><td><pre>    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Hippos'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"179\"></td><td><pre>    <span class=\"token literal-property property\">artist</span><span class=\"token operator\">:</span> <span class=\"token string\">'Taipei Zoo'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"180\"></td><td><pre>    <span class=\"token literal-property property\">description</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"181\"></td><td><pre>      <span class=\"token string\">'The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"182\"></td><td><pre>    <span class=\"token literal-property property\">url</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://i.imgur.com/6o5Vuyu.jpg'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"183\"></td><td><pre>    <span class=\"token literal-property property\">alt</span><span class=\"token operator\">:</span> <span class=\"token string\">'A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"184\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"185\"></td><td><pre><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"186\"></td><td><pre></pre></td></tr><tr><td data-num=\"187\"></td><td><pre><span class=\"token comment\">// Make UI match the initial state.</span></pre></td></tr><tr><td data-num=\"188\"></td><td><pre><span class=\"token function\">updateDOM</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h1 id=\"官方文档关于这部分的讲解\"><a class=\"anchor\" href=\"#官方文档关于这部分的讲解\">#</a> 官方文档关于这部分的讲解</h1>\n<p><img data-src=\"https://i.328888.xyz/2023/03/04/G4KFq.png\" alt=\"\" /></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iZXRhLnJlYWN0anMub3JnL2xlYXJuL3N0YXRlLWEtY29tcG9uZW50cy1tZW1vcnkjZ2l2aW5nLWEtY29tcG9uZW50LW11bHRpcGxlLXN0YXRlLXZhcmlhYmxlcw==\">官方文档这部分解释的链接</span></p>\n",
            "tags": [
                "笔记",
                "前端",
                "React",
                "React学习",
                "前端",
                "React",
                "ReactHooks"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/differenceWithVue/",
            "url": "https://zimu-66ccff.github.io/differenceWithVue/",
            "title": "React 和 Vue的区别",
            "date_published": "2023-02-25T08:52:19.000Z",
            "content_html": "<h1 id=\"对数据管理和页面渲染的解析\"><a class=\"anchor\" href=\"#对数据管理和页面渲染的解析\">#</a> 对数据管理和页面渲染的解析</h1>\n<ul>\n<li>Vue\n<ul>\n<li>用户只需要去关心数据，而完全不需要关心界面是怎么渲染怎么更新的，响应式数据一改变，vue 内部就会做数据劫持，触发收集的依赖，从而调用 render 函数完成视图的更新，这都是 vue 帮我们做好的，我们只需要关心数据。</li>\n</ul>\n</li>\n<li>React\n<ul>\n<li>React 是没有数据劫持的，我们想要界面随着数据更新而更新就必须调用 <code>setState</code> , 而调用 <code>setState</code>  实际上不仅改了数据，内部还相当于调用了 <code>render</code>  函数来对页面进行更新，也就是说用户不仅仅需要去关心数据的改变，还需要手动的去触发页面的渲染更新。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"dom-的渲染\"><a class=\"anchor\" href=\"#dom-的渲染\">#</a> DOM 的渲染</h1>\n<ul>\n<li>\n<p>Vue</p>\n<ul>\n<li>template -&gt; 编译器 -&gt; h 函数 -&gt; 虚拟 DOM -&gt; render 函数 -&gt; 真实 DOM</li>\n<li>组件的 render 函数里面的 h 函数 -&gt; 虚拟 DOM -&gt; render 函数 -&gt; 真实 DOM</li>\n</ul>\n</li>\n<li>\n<p>React</p>\n<ul>\n<li>JSX -&gt; React.createElement () -&gt; 虚拟 DOM -&gt; ReactDom.render () -&gt; 真实 DOM</li>\n<li>React.createElement () -&gt; 虚拟 DOM -&gt; ReactDom.render () -&gt; 真实 DOM<br />\nps: babel 会自动将 JSX 代码交给 React.createElement 来处理以生成虚拟 DOM</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"组件的创建\"><a class=\"anchor\" href=\"#组件的创建\">#</a> 组件的创建</h1>\n<ul>\n<li>Vue<br />\nSFC 单文件组件，即.vue 文件</li>\n<li>React\n<ol>\n<li>函数组件，类组件，本质都是返回一个 JSX.</li>\n<li>类组件有自己的状态 <code>state</code></li>\n<li>函数组件需要借助 hooks 来拥有自己的状态</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"书写-html-的形式\"><a class=\"anchor\" href=\"#书写-html-的形式\">#</a> 书写 html 的形式</h1>\n<ul>\n<li>\n<p>Vue<br />\n<strong> 模板语法</strong></p>\n<ol>\n<li>在 <code>&#123;&#123;&#125;&#125;</code>  里面书写 js 表达式，存在模板语法，v-bind，v-model，v-on 等</li>\n</ol>\n</li>\n<li>\n<p>React<br />\n<strong>JSX</strong></p>\n<ol>\n<li>只能有一个根节点</li>\n<li>在 <code>&#123;&#125;</code>  里面写 JS 表达式，但是写子文本节点的时候有以下规则</li>\n</ol>\n<ul>\n<li>Number，String， Array 类型可以直接显示为子文本节点，Array 类型会转成字符串展示为文本节点</li>\n<li>null， undefined，Boolean 会显示为空文本节点</li>\n<li>object 类型不能作为子文本节点</li>\n</ul>\n<ol start=\"3\">\n<li>注释要以 <code>&#123;/* */&#125;</code>  的形式书写</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"让组件接收-dom-并展示在组件里的指定位置\"><a class=\"anchor\" href=\"#让组件接收-dom-并展示在组件里的指定位置\">#</a> 让组件接收 DOM 并展示在组件里的指定位置</h1>\n<ul>\n<li>Vue<br />\n <code>slot</code>  插槽来实现\n<ul>\n<li>作用域插槽，让插槽的内容能够访问到子组件的状态<br />\n在子组件的 <code>&lt;slot/&gt;</code>  上通过属性来定义传递给父组件的信息，父组件在插槽里通过 <code>v-slot=xxx</code>  来获取</li>\n</ul>\n</li>\n<li>React\n<ol>\n<li><code>prop.children</code>  属性来实现，在组件里面写的内容会被添加到 <code>prop.children</code> ，当子节点个数为一个的时候， <code>children</code>  就为这个子节点，当子节点为多个的时候， <code>children</code>  为一个数组</li>\n<li>通过给 <code>prop</code>  传递 JSX 来实现（更推荐这种）</li>\n</ol>\n<ul>\n<li>类似作用域插槽的实现<br />\n父组件传递给子组件一个属性，属性值为一个函数，返回一个 JSX，JSX 也就是要让子组件展示的内容；然后子组件调用这个函数，通过传参数来给父组件传递信息</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"生命周期\"><a class=\"anchor\" href=\"#生命周期\">#</a> 生命周期</h1>\n<ul>\n<li>Vue<br />\n<img data-src=\"https://i.328888.xyz/2023/02/27/e2qPy.png\" alt=\"Vue生命周期\" /></li>\n<li>React<br />\n<img data-src=\"https://i.328888.xyz/2023/02/27/eH4IH.png\" alt=\"React生命周期\" /></li>\n</ul>\n<h1 id=\"父子组件通信\"><a class=\"anchor\" href=\"#父子组件通信\">#</a> 父子组件通信</h1>\n<ul>\n<li>Vue\n<ul>\n<li>父传子时子组件对传递过来的属性做验证，设置默认值<br />\n通过 <code>defineProps</code>  给其传递一个校验对象，在校验对象里面设置默认值</li>\n<li>子组件向父组件传递事件<br />\n通过 <code>defineEmit</code>  定义事件，父组件监听这个事件，然后子组件通过 <code>emit</code>  发送事件</li>\n</ul>\n</li>\n<li>React\n<ul>\n<li>父传子时子组件对传递过来的属性做验证<br />\n通过从 <code>prop-types</code>  包中导入 <code>PropTypes</code>  进行校验，通过给组件添加 <code>deafultProps</code>  属性来添加默认值</li>\n<li>子组件向父组件传递事件<br />\n父组件给子组件传递一个函数作为 <code>prop</code> , 子组件调用父组件传过来的属性里面存储的函数，来修改父组件的状态</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"爷孙组件通信\"><a class=\"anchor\" href=\"#爷孙组件通信\">#</a> 爷孙组件通信</h1>\n<ul>\n<li>Vue<br />\nprovide, inject</li>\n<li>React\n<ul>\n<li>Context（超级麻烦，一般不用）</li>\n</ul>\n<ol>\n<li><code>React.createContext()</code>  返回一个上下文组件比如 <code>MyContext</code></li>\n<li>在爷爷组件里面用 <code>&lt;MyContext.Provider&gt;&lt;/MyContext.Provider&gt;</code> , 通过 value 属性来传递要传递给孙子的值， 上下文组件里面嵌套要传递给哪个孙子组件的后代。</li>\n<li>在孙子组件里面，如果是类组件比如 <code>sunZi</code> ，就通过 <code>sunZi.contextType = MyContext</code>  来指定自己接收哪个 context，然后通过 <code>this.context</code>  来使用。如果是函数组件，则通过 <code>&lt;MyContext.consumer&gt;(value) =&gt; &#123;&#125;&lt;/MyContext.consumer&gt;</code>  来使用，参数 value 就是传递过来的数据<br />\n<strong>这。。。。。。谁发明的反人类的玩意，其他具体的使用去看文档吧，实在不想写了</strong></li>\n</ol>\n</li>\n</ul>\n<h1 id=\"界面的更新为异步操作在修改状态后使用新的状态的解决方案\"><a class=\"anchor\" href=\"#界面的更新为异步操作在修改状态后使用新的状态的解决方案\">#</a> 界面的更新为异步操作，在修改状态后，使用新的状态的解决方案</h1>\n<ul>\n<li>Vue<br />\nnextick 里面传一个回调函数，这个回调函数会在页面更新后调用</li>\n<li>React<br />\nsetState 中给第二个参数传一个回调函数，这个回调函数会在页面更新完毕后调用</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ol>\n<li>界面的更新为异步操作的原因：<br />\nVue 和 React 都是一样的，都是避免状态的多次改变导致多次调用 render 函数，影响性能，都想在同步代码（包含对状态的修改）执行完毕后，再一次性的调用 render 函数，对界面进行更新，提高性能。</li>\n<li>二者的不同：<br />\nVue 对响应式数据的更新是同步的，所以它会把触发的多次副作用（对界面的更新）放进一个 <code>Set</code> ，利用自动去重的机制，相同的渲染操作只执行一次。<br />\nReact 对状态的更改也是异步的，所以它会把多次状态的更改放进一个队列，然后合并每次对状态的修改，然后拿这个最终的状态去更改状态，并调用 render 函数进行渲染，从而做到只执行一次渲染。</li>\n<li>React18 之前的版本和 React18 版本中对于 setState 特殊情况的处理<br />\n React18 之前的版本：在事件里面，setTimeout，Promise 等这些的 <code>callback</code>  中 <code>setState</code>  是同步的<br />\n React18 中：上面这些特殊情况里面 <code>setState</code>  也已经是异步的了，原因同上，如果这些特殊情况还是想让 <code>setState</code>  为同步的话，需要从 <code>react-dom</code>  中引入一个 <code>flashSync</code>  方法，在里面传递一个 <code>callback</code> ，在 <code>callback</code>  里面调用 <code>setState</code>  则为同步</li>\n</ol>\n<h1 id=\"react-性能优化我认为是比-vue-强大的一点\"><a class=\"anchor\" href=\"#react-性能优化我认为是比-vue-强大的一点\">#</a> React 性能优化 (我认为是比 Vue 强大的一点)</h1>\n<ol>\n<li>\n<p>SCU</p>\n<ul>\n<li>原理:<br />\n 可以在 shouldComponentUpdate 这个生命周期钩子函数里面，从参数里拿到 <code>newState</code> , <code>newProps</code>  和当前的 <code>state</code> , <code>props</code>  作比较，当有 <code>key</code>  对应的 <code>value</code>  不一样的时候才返回 <code>true</code>  才调用 render 函数返回 jsx，进行 diff，然后更新变化了的部分。（而 Vue 完全没有这个说法，只要父组件发生了更新，就会对子组件调用 render 函数生成虚拟 DOM，然后开始比较新旧 DOM, 这个过程是避免不了的，只不过 Vue 是在 render 函数内部对新旧 DOM 做了一个比较判断，但是虚拟 DOM 生成这一步的开销避免不了）</li>\n<li>自动化 SCU 解决方案<br />\n类组件：extends pureComponent<br />\n 函数组件：用 memo 方法把函数组件包裹起来 然后返回一个新的组件</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"对表单元素的处理\"><a class=\"anchor\" href=\"#对表单元素的处理\">#</a> 对表单元素的处理</h1>\n<ul>\n<li>Vue<br />\n 利用 <code>v-model</code>  语法糖来实现双向绑定</li>\n<li>React<br />\nReact 没有双向绑定，需要给 JSX 表单元素的 <code>value</code>  属性手动绑定一个变量，然后监听 change 事件，当 change 事件被触发的时候拿 <code>event.target.value</code>  来通过 <code>setState</code>  修改绑定的变量</li>\n</ul>\n<h1 id=\"对-dom-和-component-的获取\"><a class=\"anchor\" href=\"#对-dom-和-component-的获取\">#</a> 对 DOM 和 Component 的获取</h1>\n<ul>\n<li>Vue<br />\n 通过给 DOM, Component 传递 <code>ref</code>  属性，然后用一个 <code>ref</code>  属性值同名的响应式变量来接收 DOM, Component。</li>\n<li>React\n<ol>\n<li>对于 DOM, 类组件，在 <code>state</code>  里通过 <code>createRef</code>  来创建一个存储 DOM, 类组件的变量，然后把这个变量赋值给 DOM, 类组件的 <code>ref</code>  属性。这个变量保存的就是 DOM，变量的 <code>current</code>  属性保存的就是 Component</li>\n<li>对于函数组件，通过 <code>forwardRef</code>  高阶函数来对函数组件进行一个包裹，此时函数组件将会有两个参数， <code>props</code> , <code>ref</code> , 再把 <code>ref</code>  这个参数用 ref 属性绑定到函数组件返回的 JSX 中的 DOM 上</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"css-的书写\"><a class=\"anchor\" href=\"#css-的书写\">#</a> CSS 的书写</h1>\n<ul>\n<li>Vue<br />\n 直接在 SFC 里面的 <code>&lt;style&gt;&lt;/style&gt;</code>  标签里面写，通过 <code>lang</code>  属性来设置自己想用的预处理器，非常方便</li>\n<li>React<br />\n 一般是使用 <code>css in js</code>  方案，需要用到 <code>styled-components</code>  库，然后默认导出一个 <code>styled</code>  方法 下面是一个使用案列<br />\n<img data-src=\"https://i.328888.xyz/2023/03/01/6Vqnd.png\" alt=\"6Vqnd.png\" /></li>\n</ul>\n<h1 id=\"动态添加类名\"><a class=\"anchor\" href=\"#动态添加类名\">#</a> 动态添加类名</h1>\n<ul>\n<li>Vue<br />\n 利用 <code>v-bind</code>  绑定 class</li>\n<li>React<br />\n 利用一个 <code>classnames</code>  的库，然后默认导出一个 <code>classNames</code>  方法，下面是一个使用案列<br />\n<img data-src=\"https://i.328888.xyz/2023/03/01/6flyy.png\" alt=\"6flyy.png\" /></li>\n</ul>\n",
            "tags": [
                "笔记",
                "前端",
                "React",
                "React学习",
                "前端",
                "React",
                "React和Vue的区别"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/dynamicRouter/",
            "url": "https://zimu-66ccff.github.io/dynamicRouter/",
            "title": "基于菜单的动态路由",
            "date_published": "2023-02-22T06:28:54.000Z",
            "content_html": "<h1 id=\"基本原理\"><a class=\"anchor\" href=\"#基本原理\">#</a> 基本原理</h1>\n<ol>\n<li>根据用户的 id 发送请求获取用户能够看到的菜单</li>\n<li>将需要动态注册的路由对象放到一个数组里面\n<ul>\n<li>路由对象在一个个单独的文件里面</li>\n<li>需要从文件中读取路由对象，然后放到数组里面（这一步我们将进行自动化操作）</li>\n</ul>\n</li>\n<li>根据菜单去匹配对应的路由对象，并将其注册\n<ul>\n<li><code>Router.addRoute('main', route)</code></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"详细步骤\"><a class=\"anchor\" href=\"#详细步骤\">#</a> 详细步骤</h1>\n<ol>\n<li>\n<p>根据用户的 id 发送请求获取用户能够看到的菜单</p>\n<ul>\n<li>这里我们看一下服务器返回给我们的信息<br />\n<img data-src=\"https://i.328888.xyz/2023/02/22/xySLq.png\" alt=\"返回的菜单信息\" /></li>\n<li>对返回的信息进行一波浅浅的分析 🤔<br />\n是一个数组，数组里面存储的是所有一级菜单的信息， <code>name</code> , <code>url</code> ，然后我们发现还有一个 <code>children</code>  熟悉，也是一个数组，里面存储的是二级菜单的信息</li>\n<li>好家伙，你现在是不是有想法了 🤔<br />\n我们直接拿着这个服务器返回给我们的数据，然后去生成菜单不就可以了吗，这样用户看见的就是他能看见的菜单了，他看不到的菜单我们也不会渲染，万事大吉 😁。</li>\n<li>这样操作带来的问题<br />\n如果用户也是一个前端呢，他直接在 url 那里输入他没有权限访问的路由，不就可以进入他本不能访问的界面了吗？哦豁，完蛋 🥲。所以我们需要动态注册路由啦，连路由都没有，我看他怎么访问，嗯哼。</li>\n</ul>\n</li>\n<li>\n<p>将需要动态注册的路由对象放到一个数组里面</p>\n<ul>\n<li>\n<p>首先明白一点，我们的路由对象是放在一个个文件里面的，这样结构更清晰<br />\n举个列子，在 <code>router/main/analysis/dashboard/dashboard.ts</code>  里面才有我们导出的路由对象，如下图<br />\n<img data-src=\"https://i.328888.xyz/2023/02/22/x4g2p.png\" alt=\"路由对象列子\" /></p>\n</li>\n<li>\n<p>像这样的文件及其里面的路由对象还有很多，接下来我们要做的就是将其放进一个数组里面，这里我们会进行自动化操作</p>\n<ul>\n<li>利用 <code>import.meta.glob(path, options)</code>  这个方法来自动获取 <code>path</code>  路径里面的所有文件，那么我们先用 <code>files = import.meta.glob('../router/main/**/*.ts')</code>  来获取一下我们在此路径里面的 ts 文件导出的路由对象吧，接下来给你们打印一下 <code>files</code>  看看。<br />\n<img data-src=\"https://i.328888.xyz/2023/02/22/x4G48.png\" alt=\"获取的files\" /><br />\n 我们发现是一个对象，key 是文件的 <code>path</code>  路径，value 却是一个箭头函数，这是因为他默认是懒加载获取的文件的，可是这样问题就来了，这样我们要怎么取出文件里面导出的路由对象呢 🤔？</li>\n<li>通过 <code>options</code>  选项来获取路由对象<br />\n别急别急， <code>import.meta.glob(path, options)</code>  方法不是还有第二个参数 <code>options</code>  吗，它是一个配置对象，我们可以设置这个配置对象的 <code>eager</code>  属性为 <code>true</code> ，好的，那我们接下来 <code>files = import.meta.glob('../router/main/**/*.ts', &#123;eager: true&#125;)</code>  这样试一下，给你们看看这样做后打印的 <code>files</code> <br />\n<img data-src=\"https://i.328888.xyz/2023/02/22/x4P4J.png\" alt=\"配置eager后的files\" /><br />\n 怎么样，是不是 value 由箭头函数变成了模块 Moudule，这个模块其实就是一个对象，然后对象里面有个 <code>default</code>  属性， <code>default</code>  属性的 value 可不就是我们导出的路由对象吗，欧克，大功告成，至此我们已经能够获取我们在文件里面导出的路由对象了。</li>\n<li>将路由对象注册到数组里面<figure class=\"highlight typescript\"><figcaption data-lang=\"typescript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> files<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">const</span> module <span class=\"token operator\">=</span> files<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  localRoutes<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">.</span>default<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>欧克，这样我们就成功的将我们在文件里面导出的路由对象放到 <code>localRoutes</code>  这个对象里面了，大功告成，顺便提醒一下这里用 <code>for in</code>  是因为数组也是一个对象嘛，相信你肯定是知道的。</li>\n</ul>\n</li>\n<li>\n<p><strong>最后读取文件里面导出的路由对象并放到一个数组里面的操作，我们最好给封装到一个函数里面，接下来是封装的函数的代码</strong></p>\n<figure class=\"highlight typescript\"><figcaption data-lang=\"typescript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">loadLocalRoutes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">// 1. 动态获取所有的路由对象，放到数组中</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">// * 路由对象都在独立的文件中</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token comment\">// * 从文件中将所有路由对象先读取数组中</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">const</span> localRoutes<span class=\"token operator\">:</span> RouteRecordRaw<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token comment\">// 1.1. 读取 router/main 所有的 ts 文件</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">const</span> files<span class=\"token operator\">:</span> Record<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">.</span>meta<span class=\"token punctuation\">.</span><span class=\"token function\">glob</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../router/main/*_/_.ts'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    eager<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token comment\">// 1.2. 将加载的对象放到 localRoutes</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> files<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">const</span> module <span class=\"token operator\">=</span> files<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    localRoutes<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">.</span>default<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token keyword\">return</span> localRoutes<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>根据菜单去匹配对应的路由对象，并将其注册</p>\n<ul>\n<li>\n<p>根据菜单匹配需要注册的路由对象，并将其放进一个数组<br />\n我们可以发现我们请求菜单返回的数据里面每一个一级菜单 or 二级菜单都是有一个 url 的，并且这个 url 和我们的路由对象的 path 是对应的，所以我们就可以基于这个来匹配。<em>但是有一个注意点，一级菜单是没有对应的界面，所以注册一级菜单对应的路由的时候，我们应该将其重定向到子菜单的第一个选项的路由</em> 。<strong>同样，这些操作，我们也可以将其封装到一个函数里面，下面是函数的实现</strong></p>\n<figure class=\"highlight typescript\"><figcaption data-lang=\"typescript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">mapMenusToRoutes</span><span class=\"token punctuation\">(</span>userMenus<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">// 1. 加载本地路由</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">const</span> localRoutes <span class=\"token operator\">=</span> <span class=\"token function\">loadLocalRoutes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">// 2. 根据菜单去匹配正确的路由</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">const</span> routes<span class=\"token operator\">:</span> RouteRecordRaw<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> menu <span class=\"token keyword\">of</span> userMenus<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> submenu <span class=\"token keyword\">of</span> menu<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>      <span class=\"token keyword\">const</span> route <span class=\"token operator\">=</span> localRoutes<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>path <span class=\"token operator\">===</span> submenu<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">// 1. 给 route 的顶层菜单增加重定向功能 (但是只需要添加一次即可)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>routes<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>path <span class=\"token operator\">===</span> menu<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>          routes<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span> path<span class=\"token operator\">:</span> menu<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">,</span> redirect<span class=\"token operator\">:</span> route<span class=\"token punctuation\">.</span>path <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token comment\">// 2. 将二级菜单对应的路径</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        routes<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>      <span class=\"token comment\">// 记录第一个被匹配到的菜单</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>firstMenu <span class=\"token operator\">&amp;&amp;</span> route<span class=\"token punctuation\">)</span> firstMenu <span class=\"token operator\">=</span> submenu</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>  <span class=\"token keyword\">return</span> routes</pre></td></tr></table></figure></li>\n<li>\n<p>最后遍历 <code>routes</code>  将里面存储的需要注册的路由对象，动态注册就可以啦</p>\n<figure class=\"highlight typescript\"><figcaption data-lang=\"typescript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> routes <span class=\"token operator\">=</span> <span class=\"token function\">mapMenusToRoutes</span><span class=\"token punctuation\">(</span>userMenus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>routes<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>route<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> router<span class=\"token punctuation\">.</span><span class=\"token function\">addRoute</span><span class=\"token punctuation\">(</span><span class=\"token string\">'main'</span><span class=\"token punctuation\">,</span> route<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>注意事项<br />\n这个动态注册路由的操作，应该是在进行登录操作，并且在登录成功跳转到 main 界面之前进行的。</p>\n</li>\n<li>\n<p>请思考，在登录操作里面跳转到主页面里面对路由做一个动态的注册真的就万事大吉了吗 🤔。</p>\n<ul>\n<li>\n<p>问题：<br />\n想象这样的一个场景，用户在登录之后进入了主界面，点击了它能看到的菜单，并进入了对应的界面，这时候用户点击了刷新会发生什么呢？答案很简单，我们在登录操作里面注册的动态路由没有了，因为用户刷新之后是不会再执行登陆操作的，也就是说刚才注册的路由不会再注册一遍，所以我们需要解决这个问题。</p>\n</li>\n<li>\n<p>解决方案：</p>\n<ul>\n<li>\n<p>粗糙的解决方案:<br />\n 在 <code>main.ts</code>  里面再执行获取需要注册的路由对象，并遍历将其注册的操作，因为刷新的时候 <code>main.ts</code>  会执行，但是我们是一般不希望 <code>main.ts</code>  里面有过多的业务代码的。</p>\n</li>\n<li>\n<p>优雅的解决方案：<br />\n将上面的操作封装成一个函数 <code>loadLocalCacheAction</code>  放进 Pinia 的 loginStore 里的 <code>action</code> , 然后在 <code>Store/index.ts</code>  里面导出一个 <code>registerStore</code>  函数，函数里面进行 <code>app.use(Pinia)</code>  使用 pinia 插件操作和 <code>loadLocalCacheAction</code>  操作，详细代码如下</p>\n<figure class=\"highlight typescript\"><figcaption data-lang=\"typescript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">&#123;</span> createPinia <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'pinia'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">&#123;</span> App <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vue'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> useLoginStore <span class=\"token keyword\">from</span> <span class=\"token string\">'./login/login'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">const</span> pinia <span class=\"token operator\">=</span> <span class=\"token function\">createPinia</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">registerStore</span><span class=\"token punctuation\">(</span>app<span class=\"token operator\">:</span> App<span class=\"token operator\">&lt;</span>Element<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token comment\">// 1.use 的 pinia</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  app<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>pinia<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token comment\">// 2. 加载本地的数据</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token keyword\">const</span> loginStore <span class=\"token operator\">=</span> <span class=\"token function\">useLoginStore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  loginStore<span class=\"token punctuation\">.</span><span class=\"token function\">loadLocalCacheAction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> registerStore<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>最后在 <code>main.js</code>  里面 <code>app.use(registerStore)</code>  调用 registerStore 函数，完成对 pinia 插件的使用，并执行 <code>loadLocalCacheAction</code>  函数，完成对动态路由的注册</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "笔记",
                "项目",
                "项目",
                "动态路由"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/security/",
            "url": "https://zimu-66ccff.github.io/security/",
            "title": "浏览器安全",
            "date_published": "2023-02-19T15:15:13.000Z",
            "content_html": "<h1 id=\"xss-攻击\"><a class=\"anchor\" href=\"#xss-攻击\">#</a> XSS 攻击</h1>\n<h3 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>XSS 指的是<strong>跨站脚本攻击</strong>，是一种代码注入攻击，本质是网站没有对恶意脚本进行过滤，导致其和普通代码混在了一起，最终被浏览器执行。</p>\n<h3 id=\"可以进行的操作\"><a class=\"anchor\" href=\"#可以进行的操作\">#</a> 可以进行的操作</h3>\n<ul>\n<li>获取页面的数据，比如 DOM，cookie，localStorage，sessionStorage</li>\n<li>DOS 攻击，向服务器发送大量的请求，占用服务器资源，导致用户无法访问服务器</li>\n<li>破坏页面结构</li>\n<li>流量劫持（将链接指向其他网站）</li>\n</ul>\n<h3 id=\"xss-攻击类型\"><a class=\"anchor\" href=\"#xss-攻击类型\">#</a> XSS 攻击类型</h3>\n<ul>\n<li>存储型 XSS 攻击<br />\n指的是恶意脚本会存储在服务器上，等到浏览器请求数据的时候，恶意脚本会返回，并执行。</li>\n<li>反射型 XSS 攻击<br />\n指的是诱导用户访问一个带有恶意代码的 url 后，服务器接收到数据后，把带有恶意代码的数据返回给浏览器，浏览器解析带有恶意脚本的数据，当作脚本执行，进行 XSS 攻击</li>\n<li>DOM 型 XSS 攻击<br />\n指的是直接通过操作 DOM 节点进行 XSS 攻击</li>\n</ul>\n<h3 id=\"如何防御-xss-攻击\"><a class=\"anchor\" href=\"#如何防御-xss-攻击\">#</a> 如何防御 XSS 攻击</h3>\n<ul>\n<li>前端程序员永远不要相信用户提交的数据，在进行拼凑 HTML 的时候，应该对字符串进行必要的转义，要考虑到拿来拼串的字符串可能带有恶意脚本。</li>\n<li>使用 CSP，CSP 的本质是建立一个白名单，这个白名单可以告诉浏览器哪些外部资源可以加载和执行，避免恶意代码的注入攻击。</li>\n<li>对敏感信息进行保护，比如对 cookie 使用 <code>http-only</code> ，使得脚本无法获取，或者使用验证码，避免脚本伪装成用户。</li>\n</ul>\n<h1 id=\"csrf-攻击\"><a class=\"anchor\" href=\"#csrf-攻击\">#</a> CSRF 攻击</h1>\n<h3 id=\"概念-2\"><a class=\"anchor\" href=\"#概念-2\">#</a> 概念</h3>\n<p>CSRF 攻击是一种跨站伪造请求攻击，攻击者诱导用户进入一个第三方网站，然后这个第三方网站就会向被攻击网站发送跨站请求，如果用户保持了登录状态，那么攻击者就会利用这个登录状态，冒充用户执行一些操作。<br />\n其本质是利用 cookie 会在同源请求中携带发送给服务器，以此来实现用户的冒充。</p>\n<h3 id=\"常见的攻击类型\"><a class=\"anchor\" href=\"#常见的攻击类型\">#</a> 常见的攻击类型</h3>\n<ul>\n<li>GET 类型的 CSRF 攻击，比如在 img 标签里面构造一个请求，当用户打开这个网站的时候，就会发送请求。</li>\n<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏他，当用户进入页面的时候自动提交表单</li>\n<li>链接类型的 CSRF 攻击，构造一个 a 标签，然后用户点击的时候触发攻击。</li>\n</ul>\n<h3 id=\"怎么防止-csrf-攻击\"><a class=\"anchor\" href=\"#怎么防止-csrf-攻击\">#</a> 怎么防止 CSRF 攻击</h3>\n<ul>\n<li>同源检测<br />\n服务器更具请求头中的 origin 和 referer 来判断请求是否来自允许访问的站点，但是 referer 可以仿造，并且会把搜索引擎的链接也给屏蔽了</li>\n<li>利用 token 进行验证<br />\n服务器向用户返回一个 token，然后用户每次请求的时候都要带 token，服务器再对这个 token 进行验证，缺点是给每个请求都加上 token 比较繁琐，并且如果请求经过负载均衡转移到了其他服务器，然后其他服务器的 session 中没有存储 token，就无法验证。</li>\n<li>利用 cookie 进行双重验证<br />\n用户在访问页面的时候，服务器向其域名添加一个 cookie，然后用户再次向服务器发送请求的时候，将这个 cookie 添加到 url 的参数中，服务器根据 cookie 中的数据和参数中的数据进行对比来验证。</li>\n<li>在设置 cookie 属性的时候设置 Samesite，限制 cookie 不能被第三方使用。</li>\n</ul>\n<h1 id=\"中间人攻击\"><a class=\"anchor\" href=\"#中间人攻击\">#</a> 中间人攻击</h1>\n<h3 id=\"概念-3\"><a class=\"anchor\" href=\"#概念-3\">#</a> 概念</h3>\n<p>中间人攻击是指攻击者分别与通信的两端建立联系，交换其所收到的数据，让通信的两端认为他们正在通过一个私密的链接直接与对方对话，攻击者可以拦截双非的对话，并插入新的内容。</p>\n<h3 id=\"攻击过程\"><a class=\"anchor\" href=\"#攻击过程\">#</a> 攻击过程</h3>\n<ul>\n<li>客户端发送请求到服务端，请求被中间人截获</li>\n<li>服务端向客户端返回公钥</li>\n<li>公钥被中间人截获，并生成一个伪造的公钥返回给客户端</li>\n<li>客户端收到伪造的公钥后，用伪造的公钥生成加密 hash 值发给服务器。</li>\n<li>中间人用自己的私钥解密获取真密钥，然后同时生成一个伪造的 hash 值发给服务器</li>\n<li>服务器用私钥解密获取假密钥，然后加密数据返回给客户端。</li>\n</ul>\n",
            "tags": [
                "笔记",
                "前端",
                "浏览器原理",
                "前端",
                "浏览器原理",
                "浏览器安全"
            ]
        },
        {
            "id": "https://zimu-66ccff.github.io/httpVersionDifference/",
            "url": "https://zimu-66ccff.github.io/httpVersionDifference/",
            "title": "浅谈http协议各版本之间，http协议与https协议之间的区别",
            "date_published": "2023-02-19T07:51:25.000Z",
            "content_html": "<h1 id=\"http11-与-http10-的区别\"><a class=\"anchor\" href=\"#http11-与-http10-的区别\">#</a> http1.1 与 http1.0 的区别</h1>\n<ul>\n<li>连接方面<br />\n http1.0 不是持久连接，每次发送请求都需要建立一个连接；http1.1 是持久连接，多次请求服用一个 tcp 连接。</li>\n<li>缓存方面<br />\n http1.0 的缓存主要是使用请求头中的 If-Modified-Sine,Expires 作为缓存判断的标准。http1.1 则增加了 Etag, if-None-match,if-Match 等更多选项来控制缓存策略</li>\n<li>资源请求方面<br />\n http1.0 请求资源的时候，有时候只是需要请求一点东西，但是服务器会把整个对象返回，存在浪费带宽的现象，并且不支持断点续传。http1.1 则在请求同中增加了 range 选项，支持只请求资源的某个部分，返回 206 状态码</li>\n<li>新增了 host 字段，来指定服务器的域名</li>\n<li>新增了 PUT,DELETE,TRACE,OPTIONS 请求方法</li>\n</ul>\n<h1 id=\"http20-与-http11-的区别\"><a class=\"anchor\" href=\"#http20-与-http11-的区别\">#</a> http2.0 与 http1.1 的区别</h1>\n<ul>\n<li>二进制协议<br />\n http1.1 里头信息必须是文本，数据体可以是文本可以是二进制。而 http2.0 则是个完全的二进制协议，头信息和数据体都必须是二进制，统称为 ' 帧'，分为头信息帧和数据帧。</li>\n<li>多路复用<br />\n http2.0 实现了多路复用，http2.0 依旧复用 tcp 连接，但是客户端和服务端都可以同时发送多个请求 or 响应，而且不用按照顺序一一发送，避免了 http 的队头阻塞。</li>\n<li>数据流<br />\n http2.0 使用了数据流的概念，因为 http2.0 的数据包不是按照顺序发送的，多个连续的数据包可能来自不同的请求 or 响应，所以需要指定他们来自哪个请求，哪个响应。http2.0 将请求 or 响应对应的所有数据包<br />\n称为一个数据流，每个数据流都有一个独一无二的编号，每个数据包发送的时候都必须带上数据流 ip，来指明它属于哪个数据流。</li>\n<li>头信息压缩<br />\n http1.1 协议不带状态，每次请求都必须带上所有的信息，所以很多字段都是重复的，这会浪费带宽，也会影响速度</li>\n<li>服务器推送<br />\n http2.0 允许服务器未经请求，主动的向客户端发送一些静态资源。</li>\n</ul>\n<h1 id=\"https-和-http-的区别\"><a class=\"anchor\" href=\"#https-和-http-的区别\">#</a> https 和 http 的区别</h1>\n<ul>\n<li>https 协议需要 CA 证书，费用较高，而 http 协议不需要</li>\n<li>http 协议是超文本传输协议，信息是明文传输的，https 是 ssl 加密传输协议，具有安全性</li>\n<li>使用不同的传输方式，端口号也不同，http 协议是运行在 80 端口 ，https 协议是运行在 443 端口</li>\n<li>http 协议很简单是无状态的，https 协议是用 ssl 协议和 http 协议构建的可加密传输，身份认证的网络协议，比 http 更安全。</li>\n</ul>\n",
            "tags": [
                "笔记",
                "前端",
                "计算机网络",
                "前端",
                "计算机网络",
                "http1.0",
                "http1.1",
                "http2.0",
                "http3.0",
                "https"
            ]
        }
    ]
}